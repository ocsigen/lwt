<html><head>

<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">





































































<title>Lwt – API reference draft</title>
<link rel="stylesheet" href="style.css">

</head>
<body>

<h1>Lwt API Reference</h1>
<div class="interface module" data-ml-identifier="Lwt"><div class="top"><pre><span class="keyword">module</span> Lwt</pre><div class="info"><p>
Asynchronous programming with promises.
</p><p>

    A <b>promise</b> is a placeholder for a single value which might take a long
    time to compute. Speaking roughly, a promise is a <code>ref</code> that can be filled
    in later. To make that precise, here is how promises differ from <code>ref</code>s:
</p><ul>
<li>A promise might not have a value yet. A promise in this state is called a
      <em>pending</em> promise.</li>
<li>Writing a value into a promise is called <em>resolving</em> it. A promise with
      a value is called a <em>resolved</em> promise.</li>
<li>Each promise can be resolved only once. After a promise has a value, the
      promise is immutable.</li>
<li>It's possible to attach <b>callbacks</b> to a promise. They will run when the
      promise has a value, i.e. is resolved. If the promise is already resolved
      when a callback is attached, the callback is run (almost) right away. If
      the promise is pending, the callback is put into a list and waits.</li>
</ul><p>

    So, promises are optional, write-once references, and when they don't yet
    have a value, they store a list of callbacks that are waiting for the value.
</p><p>

    The waiting callbacks make promises a natural data type for asynchronous
    programming. For example, you can ask Lwt to <code>read</code> a file. Lwt immediately
    returns you only a <em>promise</em> for the data.
</p><p>

    You can neglect this promise for a while. You can do some other computation,
    request more <span class="acronym">I/O</span>, etc. At some point, you might decide to attach a callback
    to the <code>read</code> promise, maybe several callbacks.
</p><p>

    In the meantime, the <code>read</code> operation is running in the background. Once it
    finishes, Lwt <em>resolves</em> the <code>read</code> promise by putting the data into it.
    Lwt then runs the callbacks you attached.
</p><p>

    One of those might take the data, and ask Lwt to <code>write</code> it to <span class="acronym">STDOUT</span>. Lwt
    gives you a promise for that, too, and the process repeats.
</p><p>

    Lwt has a small amount of syntactic sugar to make this look as natural as
    possible:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> data = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_io</span>.printl data <span class="keyword">in</span>
    <span class="constructor">Lwt</span>.return ()
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix echo.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    This is all explained in the next sections:
</p><ul>
<li><a href=" #3_Quickstart"> Quick start</a> links these concepts to actual functions
      in Lwt – the most fundamental ones.</li>
<li><a href=" #3_Tutorial"> Tutorial</a> shows how to write examples like the above, and
      how concurrency happens.</li>
<li><a href=" #3_Executionmodel"> Execution model</a> clarifies control flow when using
      Lwt.</li>
<li><a href=" #3_GuidetotherestofLwt"> Guide to the rest of Lwt</a> shows how
      <em>everything</em> else in Lwt fits into this framework.</li>
</ul><p>

    After that is the <a href=" 2_Fundamentals"> reference proper</a>, which goes into
    <em>painful</em> levels of detail on every single type and value in this module,
    <code>Lwt</code>. Please be safe, and read only what you need from it :)
</p><p>

    Happy asynchronous programming!
</p></div></div><div class="items">

<h3 id="3_Quickstart"><a class="anchor" href="#3_Quickstart">¶</a>Quick start</h3><div class="info"><p>

    <em>All</em> of Lwt is variations on:
</p><ul>
<li><b>Promises</b> of type <a href="Lwt.html#TYPEt"><code>α&nbsp;Lwt.t</code></a> are placeholders for values of type
      <code>α</code>.</li>
<li><a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> attaches <b>callbacks</b> to promises. When a promise gets a
      value, its callbacks are called.</li>
<li>Separate <b>resolvers</b> of type <a href="Lwt.html#TYPEu"><code>α&nbsp;Lwt.u</code></a> are used to write values into
      promises, through <a href="Lwt.html#VALwakeup_later"><code>Lwt.wakeup_later</code></a>.</li>
<li>Promises and resolvers are created in pairs using <a href="Lwt.html#VALtask"><code>Lwt.task</code></a>. Lwt <span class="acronym">I/O</span>
      functions call <a href="Lwt.html#VALtask"><code>Lwt.task</code></a> internally, but return only the promise.</li>
<li><a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> is used to wait on one “top-level” promise. When that
      promise gets a value, the program terminates.</li>
</ul></div><h3 id="3_Tutorial"><a class="anchor" href="#3_Tutorial">¶</a>Tutorial</h3><div class="info"><p>

    Let's read  from <span class="acronym">STDIN</span>. The first version is written using ordinary values
    from the OCaml standard library. This makes the program block until the user
    enters a line:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> line : string =
    <span class="constructor">Pervasives</span>.read_line () <span class="keyword">in</span>
  print_endline <span class="string">"Now unblocked!"</span>;
  ignore line

<span class="comment">(* ocamlfind opt -linkpkg code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    If we use a promise instead, execution continues immediately:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> line_promise : string <span class="constructor">Lwt</span>.t =
    <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
  print_endline <span class="string">"Execution just continues..."</span>;
  ignore line_promise

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    Indeed, this program is a little <em>too</em> asynchronous – it exits right away!
    Let's force it to wait for <code>line_promise</code> at the end by calling
    <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> line_promise : string <span class="constructor">Lwt</span>.t =
    <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
  print_endline <span class="string">"Execution just continues..."</span>;

  <span class="keyword">let</span> line : string =
    <span class="constructor">Lwt_main</span>.run line_promise <span class="keyword">in</span>
  ignore line

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> should only be called once, on one promise, at the top level
    of your program. Most of the time, waiting for promises is done using
    <code>let%lwt</code>. That is the recommended syntactic sugar for <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, and is
    pronounced “bind”:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p : unit <span class="constructor">Lwt</span>.t =
    <span class="keyword">let%lwt</span> line_1 = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> line_2 = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printf <span class="string">"%s and %s\n"</span> line_1 line_2
  <span class="keyword">in</span>

  <span class="constructor">Lwt_main</span>.run p

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    The way that works is everything in scope after the “<code>in</code>” in
    “<code>let%lwt&nbsp;x&nbsp;=</code> ... <code>in</code> ...” goes into a callback, and “<code>x</code>” is that
    callback's argument. So, we could have been very explicit, and written the
    code like this:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p : unit <span class="constructor">Lwt</span>.t =
    <span class="keyword">let</span> line_1_promise : string <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt</span>.bind line_1_promise (<span class="keyword">fun</span> (line_1 : string) <span class="keywordsign">-&gt;</span>

      <span class="keyword">let</span> line_2_promise : string <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
      <span class="constructor">Lwt</span>.bind line_2_promise (<span class="keyword">fun</span> (line_2 : string) <span class="keywordsign">-&gt;</span>

        <span class="constructor">Lwt_io</span>.printf <span class="string">"%s and %s\n"</span> line_1 line_2))
  <span class="keyword">in</span>

  <span class="constructor">Lwt_main</span>.run p

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    But, as you can see, this is verbose, and the indentation gets a bit crazy.
    So, we will always use <code>let%lwt</code>.
</p><p>

    The code above reads two lines in sequence, because we ask Lwt to wait for
    <code>line_1</code>, before calling the second <a href="Lwt_io.html#VALread_line"><code>Lwt_io.read_line</code></a> in the callback, to
    start the second <span class="acronym">I/O</span>.
</p><p>

    We could also run <span class="acronym">I/O</span> <em>concurrently</em>. All we have to do is not start the
    second <span class="acronym">I/O</span> in a callback of the first. Because it doesn't make sense to read
    two lines from <span class="acronym">STDIN</span> concurrently, let's start two waits instead:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let</span> three_seconds : unit <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_unix</span>.sleep 3. <span class="keyword">in</span>
    <span class="keyword">let</span> five_seconds : unit <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_unix</span>.sleep 5. <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = three_seconds <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_io</span>.printl <span class="string">"3 seconds passed"</span> <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = five_seconds <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl <span class="string">"Only 2 more seconds passed"</span>
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    This program takes about five seconds to run. We are still new to <code>let%lwt</code>,
    so let's desugar it:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let</span> three_seconds : unit <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_unix</span>.sleep 3. <span class="keyword">in</span>
    <span class="keyword">let</span> five_seconds : unit <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_unix</span>.sleep 5. <span class="keyword">in</span>

    <span class="comment">(* Both waits have already been started at this point! *)</span>

    <span class="constructor">Lwt</span>.bind three_seconds (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
      <span class="comment">(* This is 3 seconds later. *)</span>
      <span class="constructor">Lwt</span>.bind (<span class="constructor">Lwt_io</span>.printl <span class="string">"3 seconds passed"</span>) (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
        <span class="constructor">Lwt</span>.bind five_seconds (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
          <span class="comment">(* Only 2 seconds were left in the 5-second wait, so
              this callback runs 2 seconds after the first callback. *)</span>
          <span class="constructor">Lwt_io</span>.printl <span class="string">"Only 2 more seconds passed"</span>)))
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    And that's it! Concurrency in Lwt is simply a matter of whether you start an
    operation in the callback of another one or not. As a convenience, Lwt
    provides a few <a href=" #2_Concurrency"> helpers</a> for common concurrency patterns.
</p></div><h3 id="3_Executionmodel"><a class="anchor" href="#3_Executionmodel">¶</a>Execution model</h3><div class="info"><p>

    It's important to understand that promises are a pure-OCaml data type. They
    don't do any fancy scheduling or <span class="acronym">I/O</span>. They are just lists of callbacks (if
    pending), or containers for one value (if resolved).
</p><p>

    The interesting function is <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>. It's a wrapper around
    <a href=" http://man7.org/linux/man-pages/man2/select.2.html"> <code>select(2)</code></a>,
    <a href=" http://man7.org/linux/man-pages/man7/epoll.7.html"> <code>epoll(7)</code></a>,
    <a href=" https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">
    <code>kqueue(2)</code></a>, or whatever asynchronous <span class="acronym">I/O</span> <span class="acronym">API</span> your system provides. On
    browsers, the work of <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> is done by the surrouding JavaScript
    engine, so you don't call <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> from inside your program. But the
    execution model is still the same, and the description below applies!
</p><p>

    To avoid writing out “underlying asynchronous <span class="acronym">I/O</span> <span class="acronym">API</span>,” we'll assume, in
    this section, that the <span class="acronym">API</span> is <code>select(2)</code>. That's just for the sake of
    abbreviation. It doesn't actually matter, for most purposes, what the
    underlying <span class="acronym">I/O</span> <span class="acronym">API</span> is.
</p><p>

    Let's use the program from the tutorial that reads two lines as an example.
    Here it is, again, in its desugared form:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p : unit <span class="constructor">Lwt</span>.t =
    <span class="keyword">let</span> line_1_promise : string <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt</span>.bind line_1_promise (<span class="keyword">fun</span> (line_1 : string) <span class="keywordsign">-&gt;</span>

      <span class="keyword">let</span> line_2_promise : string <span class="constructor">Lwt</span>.t = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
      <span class="constructor">Lwt</span>.bind line_2_promise (<span class="keyword">fun</span> (line_2 : string) <span class="keywordsign">-&gt;</span>

        <span class="constructor">Lwt_io</span>.printf <span class="string">"%s and %s\n"</span> line_1 line_2))
  <span class="keyword">in</span>

  <span class="constructor">Lwt_main</span>.run p

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> is your program's main <span class="acronym">I/O</span> loop. You pass it a single
    promise, and it:
</p><p><ol>
<li>Uses <code>select(2)</code> to put your process to sleep until the next <span class="acronym"><span class="acronym">I/O</span></span>
      completes.</li>
<li>That next <span class="acronym"><span class="acronym">I/O</span></span> happens to be the one that reads <code>line_1</code>. <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>
      knows that <span class="acronym"><span class="acronym">I/O</span></span> is supposed to resolve <code>line_1_promise</code>, so it puts
      <code>line_1</code> into the promise and resolves it.</li>
<li>Resolving is an ordinary OCaml operation. It causes all the callbacks of
      <code>line_1_promise</code> to run, one after another. Each callback is also ordinary
      OCaml code. In our case, there is only one callback, but in general, there
      might be several, and they might also resolve additional promises. So,
      promise resolution triggers a “cascade” of callbacks. Eventually, however,
      we should run out of callbacks, and control will return to
      <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>.</li>
<li>In our example, our one callback registers a second <span class="acronym"><span class="acronym">I/O</span></span> with
      <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> – the one that will read <code>line_2</code>. There are no callbacks
      left to run after that, so control returns to <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>.</li>
<li><a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> goes back to sleep again by calling <code>select(2)</code>, now
      waiting for the second <span class="acronym"><span class="acronym">I/O</span></span> that we just registered. The loop repeats
      itself from step 1.</li>
</ol>

    This has two major implications, one good and one bad. Let's start with the
    bad one.
</p><p>

    <b>(1)</b> If one of your callbacks enters an infinite loop, calls an
    Lwt-unfriendly blocking <span class="acronym">I/O</span>, or just runs for a really long time, it won't
    return control to <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> anytime soon. That means <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>
    won't get a chance to resolve any other Lwt <span class="acronym">I/O</span> promises, even if the
    underlying <span class="acronym">I/O</span> operations complete.
</p><p>

    In case your callback is just using the <span class="acronym">CPU</span> for a really long time, you can
    insert a few calls to <a href="Lwt_main.html#VALyield"><code>Lwt_main.yield</code></a> into it, and resume your computation
    in callbacks of <code>yield</code>. This is basically the same as <code>Lwt_unix.sleep&nbsp;0.</code>
    – it's a promise that will be resolved by <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> <em>after</em> any
    other <span class="acronym">I/O</span> resolutions that are already in its queue.
</p><p>

    <b>(2)</b> The good implication is that all your callbacks run in a single
    thread. This means that in most situations, you don't have to worry about
    locks, synchronization, etc. Anything that is in the same callback is
    guaranteed to run without interruption. Lwt programs are often <em>much</em>
    easier to write and refactor, than equivalent programs written with threads
    – but both are concurrent!
</p></div><h3 id="3_GuidetotherestofLwt"><a class="anchor" href="#3_GuidetotherestofLwt">¶</a>Guide to the rest of Lwt</h3><div class="info"><p>

    This module <code>Lwt</code> is the pure-OCaml definition of promises and
    callback-calling. It has a few extras on top of what's described above:
</p><ul>
<li><a href=" #2_Rejection"> Rejection</a>. Lwt promises can actually be resolved in two
      ways: <em>fulfilled</em> with a value, or <em>rejected</em> with an exception. There
      is nothing conceptually special about rejection – it's just that you can
      ask for callbacks to run only on fulfillment, only on rejection, etc.</li>
<li><a href=" #2_Cancelation"> Cancelation</a>. This is a special case of rejection,
      specifically with exception <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a>. It has extra helpers in the
      Lwt <span class="acronym">API</span>.</li>
<li><a href=" #2_Concurrency"> Concurrency helpers</a>. All of these could be
      implemented on top of <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>. As we saw, Lwt concurrency requires
      only deciding whether to run something inside a callback, or outside it.
      These functions just implement common patterns, and make intent explicit.</li>
<li>Miscellaneous <a href=" #2_Convenience"> helpers</a>, and <a href=" #2_Deprecated">
      deprecated</a> <span class="acronym">API</span>s.</li>
</ul><p>

    The next layer above module <code>Lwt</code> is the pure-OCaml Lwt “core” library,
    which provides some promise-friendly patterns, like streams and mvars. This
    consists of the modules <a href="Lwt_list.html"><code>Lwt_list</code></a>, <a href="Lwt_stream.html"><code>Lwt_stream</code></a>, <a href="Lwt_result.html"><code>Lwt_result</code></a>,
    <a href="Lwt_mutex.html"><code>Lwt_mutex</code></a>, <a href="Lwt_condition.html"><code>Lwt_condition</code></a>, <a href="Lwt_mvar.html"><code>Lwt_mvar</code></a>, <a href="Lwt_pool.html"><code>Lwt_pool</code></a>, and <a href="Lwt_switch.html"><code>Lwt_switch</code></a>.
</p><p>

    Above that is the Lwt Unix binding, where <span class="acronym">I/O</span> begins. This includes the
    module <a href="Lwt_main.html"><code>Lwt_main</code></a>, including the all-important <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>. The rest of
    the Unix binding consists of functions, each one of which...
</p><ul>
<li>...starts a background <span class="acronym">I/O</span> operation,</li>
<li>creates a promise for it and gives it to you,</li>
<li>registers with <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>, so if you attach callbacks to the promise,
      they will be called when the <span class="acronym">I/O</span> operation completes.</li>
</ul><p>

    The functions are grouped into modules:
</p><ul>
<li><a href="Lwt_unix.html"><code>Lwt_unix</code></a> for Unix system calls.</li>
<li><a href="Lwt_bytes.html"><code>Lwt_bytes</code></a> for Unix system calls on bigarrays.</li>
<li><a href="Lwt_io.html"><code>Lwt_io</code></a> for <code>Pervasives</code>-like high-level channels, TCP servers, etc.</li>
<li><a href="Lwt_process.html"><code>Lwt_process</code></a> for managing subprocesses.</li>
<li><a href="Lwt_preemptive.html"><code>Lwt_preemptive</code></a> for spawning system threads.</li>
<li>Miscellaneous modules <a href="Lwt_daemon.html"><code>Lwt_daemon</code></a>, <a href="Lwt_gc.html"><code>Lwt_gc</code></a>, <a href="Lwt_log.html"><code>Lwt_log</code></a>, <a href="Lwt_engine.html"><code>Lwt_engine</code></a>,
      <a href="Lwt_throttle.html"><code>Lwt_throttle</code></a>, <a href="Lwt_timeout.html"><code>Lwt_timeout</code></a>, <a href="Lwt_sys.html"><code>Lwt_sys</code></a>.</li>
</ul><p>

    Finally, there are some modules, which notionally belong in the core library
    or the Unix binding, but are kept separate because they have additional
    dependencies on external libraries. These are <a href="Lwt_react.html"><code>Lwt_react</code></a>, <a href="Lwt_ssl.html"><code>Lwt_ssl</code></a>, and
    <a href="Lwt_glib.html"><code>Lwt_glib</code></a>. <a href="Lwt_react.html"><code>Lwt_react</code></a> notionally belongs in the core, and the other two
    work like the Unix binding.
</p><p>

    Warning! Introductory material ends and detailed reference begins!
</p></div><div class="toc"><h3 id="toc"><a class="anchor" href="#toc">¶</a>Table of contents</h3><a class="level-2" href="#">[Top]</a><br><a class="level-2" href="#3_Quickstart">Quick start</a><br><a class="level-2" href="#3_Tutorial">Tutorial</a><br><a class="level-2" href="#3_Executionmodel">Execution model</a><br><a class="level-2" href="#3_GuidetotherestofLwt">Library guide</a><br><a class="level-2" href="#2_Fundamentals">Fundamentals</a><br><a class="level-3" href="#3_Promises">Promises</a><br><a class="level-3" href="#3_Resolving">Resolving</a><br><a class="level-3" href="#3_Callbacks">Callbacks</a><br><a class="level-2" href="#2_Rejection">Rejection</a><br><a class="level-2" href="#2_Concurrency">Concurrency</a><br><a class="level-3" href="#3_Multiplewait">Multiple wait</a><br><a class="level-3" href="#3_Racing">Racing</a><br><a class="level-2" href="#2_Cancelation">Cancelation</a><br><a class="level-2" href="#2_Convenience">Convenience</a><br><a class="level-3" href="#3_Callbackhelpers">Callback helpers</a><br><a class="level-3" href="#3_Infixoperators">Infix operators</a><br><a class="level-3" href="#3_Preallocatedpromises">Pre-allocated promises</a><br><a class="level-3" href="#3_Resulttype">Result type</a><br><a class="level-3" href="#3_Statequery">State query</a><br><a class="level-2" href="#2_Deprecated">Deprecated</a></div><h2 id="2_Fundamentals"><a class="anchor" href="#2_Fundamentals">¶</a>Fundamentals</h2><h3 id="3_Promises"><a class="anchor" href="#3_Promises">¶</a>Promises</h3><div data-ml-fq-identifier="Lwt.t" data-ml-identifier="t" data-ml-kind="type" class="item"><pre><a class="anchor" href="#TYPEt">¶</a><span id="TYPEt"><span class="keyword">type</span> <code class="type">+α</code> t</span> </pre>
<div class="info "><p>
Promises for values of type <code>α</code>.
</p><p>

    A <b>promise</b> is a memory cell that is always in one of three <b>states</b>:
</p><ul>
<li><em>fulfilled</em>, and containing one value of type <code>α</code>,</li>
<li><em>rejected</em>, and containing one exception, or</li>
<li><em>pending</em>, in which case it may become fulfilled or rejected later.</li>
</ul><p>

    A <em>resolved</em> promise is one that is either fulfilled or rejected, i.e. not
    pending. Once a promise is resolved, its content cannot change. So, promises
    are <em>write-once references</em>. The only possible state changes are (1) from
    pending to fulfilled and (2) from pending to rejected.
</p><p>

    Promises are typically “read” by attaching <b>callbacks</b> to them. The most
    basic functions for that are <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, which attaches a callback that is
    called when a promise becomes fulfilled, and <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>, for rejection.
</p><p>

    Promises variables of this type, <code>α&nbsp;Lwt.t</code>, are actually <b>read-only</b> in
    Lwt. Separate <em>resolvers</em> of type <a href="Lwt.html#TYPEu"><code>α&nbsp;Lwt.u</code></a> are used to write to them.
    Promises and their resolvers are created together by calling <a href="Lwt.html#VALtask"><code>Lwt.task</code></a>.
    There is one exception to this: most promises can be <em>canceled</em> by calling
    <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>, without going through a resolver.
</p></div>


</div><div data-ml-fq-identifier="Lwt.u" data-ml-identifier="u" data-ml-kind="type" class="item"><pre><a class="anchor" href="#TYPEu">¶</a><span id="TYPEu"><span class="keyword">type</span> <code class="type">α</code> u</span> </pre>
<div class="info "><p>
Resolvers for promises of type <a href="Lwt.html#TYPEt"><code>α&nbsp;Lwt.t</code></a>.
</p><p>

    Each resolver can be thought of as the <b>write end</b> of one promise. It can
    be passed to <a href="Lwt.html#VALwakeup_later"><code>Lwt.wakeup_later</code></a>, <a href="Lwt.html#VALwakeup_later_exn"><code>Lwt.wakeup_later_exn</code></a>, or
    <a href="Lwt.html#VALwakeup_later_result"><code>Lwt.wakeup_later_result</code></a> to resolve that promise.
</p></div>


</div><div data-ml-fq-identifier="Lwt.task" data-ml-identifier="task" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALtask">¶</a><span id="VALtask"><span class="keyword">val</span> task</span> : <code class="type">unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> * α <a href="Lwt.html#TYPEu">Lwt.u</a></code></pre><div class="info "><p>
Creates a new pending <a href=" #TYPEt"> promise</a>, paired with its <a href=" #TYPEu">
    resolver</a>.
</p><p>

    It is rare to use this function directly. Many helpers in Lwt, and Lwt-aware
    libraries, call it internally, and return only the promise. You then chain
    the promises together using <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>.
</p><p>

    However, it is important to understand <code>Lwt.task</code> as the fundamental promise
    “constructor.” All other functions that evaluate to a promise can be, or
    are, eventually implemented in terms of it.
</p></div>

</div><h3 id="3_Resolving"><a class="anchor" href="#3_Resolving">¶</a>Resolving</h3><div data-ml-fq-identifier="Lwt.wakeup_later" data-ml-identifier="wakeup_later" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_later">¶</a><span id="VALwakeup_later"><span class="keyword">val</span> wakeup_later</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ α ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_later&nbsp;r&nbsp;v</code> <em>fulfills</em>, with value <code>v</code>, the <em>pending</em>
    <a href=" #TYPEt"> promise</a> associated with <a href=" #TYPEu"> resolver</a> <code>r</code>. This
    triggers callbacks attached to the promise.
</p><p>

    If the promise is not pending, <code>Lwt.wakeup_later</code> raises
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinvalid_arg">
    <code>Pervasives.Invalid_argument</code></a>, unless the promise is <a href=" #VALcancel">
    canceled</a>. If the promise is canceled, <code>Lwt.wakeup_later</code> has no effect.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wakeup_later_exn" data-ml-identifier="wakeup_later_exn" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_later_exn">¶</a><span id="VALwakeup_later_exn"><span class="keyword">val</span> wakeup_later_exn</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ exn ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_later_exn&nbsp;r&nbsp;exn</code> is like <a href="Lwt.html#VALwakeup_later"><code>Lwt.wakeup_later</code></a>, except, if the
    associated <a href=" #TYPEt"> promise</a> is <em>pending</em>, it is <em>rejected</em> with
    <code>exn</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return" data-ml-identifier="return" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn">¶</a><span id="VALreturn"><span class="keyword">val</span> return</span> : <code class="type">α ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return&nbsp;v</code> creates a new <a href=" #TYPEt"> promise</a> that is <em>already
    fulfilled</em> with value <code>v</code>.
</p><p>

    This is needed to satisfy the type system in some cases. For example, in a
    <code>match</code> expression where one case evaluates to a promise, the other cases
    have to evaluate to promises as well:
</p><pre><code><span class="keyword">match</span> need_input <span class="keyword">with</span>
<span class="keywordsign">|</span> <span class="keyword">true</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.(read_line stdin)   <span class="comment">(* Has type string Lwt.t... *)</span>
<span class="keywordsign">|</span> <span class="keyword">false</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt</span>.return <span class="string">""</span>             <span class="comment">(* ...so wrap empty string in a promise. *)</span>
</code></pre><p>

    Another typical usage is in <a href=" #VALbind"> <code>let%lwt</code></a>. The expression after
    the “<code>in</code>” has to evaluate to a promise. So, if you compute an ordinary
    value instead, you have to wrap it:
</p><pre><code><span class="keyword">let%lwt</span> line = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
<span class="constructor">Lwt</span>.return (line ^ <span class="string">"."</span>)
</code></pre></div>

</div><div data-ml-fq-identifier="Lwt.fail" data-ml-identifier="fail" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALfail">¶</a><span id="VALfail"><span class="keyword">val</span> fail</span> : <code class="type">exn ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.fail&nbsp;exn</code> is like <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a>, except the new <a href=" #TYPEt"> promise</a>
    that is <em>already rejected</em> with <code>exn</code>.
</p></div>

</div><h3 id="3_Callbacks"><a class="anchor" href="#3_Callbacks">¶</a>Callbacks</h3><div data-ml-fq-identifier="Lwt.bind" data-ml-identifier="bind" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALbind">¶</a><span id="VALbind"><span class="keyword">val</span> bind</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.bind&nbsp;p_1&nbsp;f</code> makes it so that <code>f</code> will run when <code>p_1</code> is <a href=" #TYPEt">
    <em>fulfilled</em></a>.
</p><p>

    When <code>p_1</code> is fulfilled with value <code>v_1</code>, the callback <code>f</code> is called with
    that same value <code>v_1</code>. Eventually, after perhaps starting some <span class="acronym">I/O</span> or other
    computation, <code>f</code> returns promise <code>p_2</code>.
</p><p>

    <code>Lwt.bind</code> itself returns immediately. It only attaches the callback <code>f</code> to
    <code>p_1</code> – it does not wait for <code>p_2</code>. <em>What</em> <code>Lwt.bind</code> returns is yet a
    third promise, <code>p_3</code>. Roughly speaking, fulfillment of <code>p_3</code> represents both
    <code>p_1</code> and <code>p_2</code> becoming fulfilled, one after the other.
</p><p>

    A minimal example of this is an echo program:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p_3 =
    <span class="constructor">Lwt</span>.bind
      <span class="constructor">Lwt_io</span>.(read_line stdin)
      (<span class="keyword">fun</span> line <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.printl line)
  <span class="keyword">in</span>
  <span class="constructor">Lwt_main</span>.run p_3

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    Rejection of <code>p_1</code> and <code>p_2</code>, and raising an exception in <code>f</code>, are all
    forwarded to rejection of <code>p_3</code>.
</p><p>

    <b>Precise behavior</b>
</p><p>

    <code>Lwt.bind</code> returns a promise <code>p_3</code> immediately. <code>p_3</code> starts out pending,
    and is resolved as follows:
</p><ul>
<li>The first condition to wait for is that <code>p_1</code> becomes resolved. It does
      not matter whether <code>p_1</code> is already resolved when <code>Lwt.bind</code> is called, or
      becomes resolved later – the rest of the behavior is the same.</li>
<li>If and when <code>p_1</code> becomes resolved, it will, by definition, be either
      fulfilled or rejected.</li>
<li>If <code>p_1</code> is rejected, <code>p_3</code> is rejected with the same exception.</li>
<li>If <code>p_1</code> is fulfilled, with value <code>v</code>, <code>f</code> is applied to <code>v</code>.</li>
<li><code>f</code> may finish by returning the promise <code>p_2</code>, or raising an exception.</li>
<li>If <code>f</code> raises an exception, <code>p_3</code> is rejected with that exception.</li>
<li>Finally, the remaining case is when <code>f</code> returns <code>p_2</code>. From that point on,
      <code>p_3</code> is effectively made into a reference to <code>p_2</code>. This means they have
      the same state, undergo the same state changes, and performing any
      operation on one is equivalent to performing it on the other.</li>
</ul><p>

    <b>Syntactic sugar</b>
</p><p>

    <code>Lwt.bind</code> is almost never written directly, because sequences of <code>Lwt.bind</code>
    result in growing indentation and many parentheses:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="constructor">Lwt</span>.bind <span class="constructor">Lwt_io</span>.(read_line stdin) (<span class="keyword">fun</span> line <span class="keywordsign">-&gt;</span>
      <span class="constructor">Lwt</span>.bind (<span class="constructor">Lwt_unix</span>.sleep 1.) (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
        <span class="constructor">Lwt_io</span>.printf <span class="string">"One second ago, you entered %s\n"</span> line))
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    The recommended way to write <code>Lwt.bind</code> is using the <code>let%lwt</code> syntactic
    sugar:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> line = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 1. <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printf <span class="string">"One second ago, you entered %s\n"</span> line
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    This uses the Lwt <a href=" Ppx_lwt.html"> <span class="acronym">PPX</span></a> (preprocessor). Note that we had to
    add package <code>lwt.ppx</code> to the command line for building this program. We will
    do that throughout this manual.
</p><p>

    Another way to write <code>Lwt.bind</code>, that you may encounter while reading code,
    is with the <code>&gt;&gt;=</code> operator:
</p><pre><code><span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

<span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="constructor">Lwt_io</span>.(read_line stdin) &gt;&gt;= <span class="keyword">fun</span> line <span class="keywordsign">-&gt;</span>
    <span class="constructor">Lwt_unix</span>.sleep 1. &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
    <span class="constructor">Lwt_io</span>.printf <span class="string">"One second ago, you entered %s\n"</span> line
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    The <code>&gt;&gt;=</code> operator comes from the module <a href="Lwt.Infix.html"><code>Lwt.Infix</code></a>, which is why we
    opened it at the beginning of the program.
</p><p>

    See also <a href="Lwt.html#VALmap"><code>Lwt.map</code></a>.
</p></div>

</div><h2 id="2_Rejection"><a class="anchor" href="#2_Rejection">¶</a>Rejection</h2><div data-ml-fq-identifier="Lwt.catch" data-ml-identifier="catch" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALcatch">¶</a><span id="VALcatch"><span class="keyword">val</span> catch</span> : <code class="type">(unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ (exn ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.catch&nbsp;f&nbsp;h</code> applies <code>f&nbsp;()</code>, which returns a promise, and then makes it
    so that <code>h</code> (“handler”) will run when that promise is <a href=" #TYPEt">
    <em>rejected</em></a>.
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="constructor">Lwt</span>.catch
      (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt</span>.fail <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span>)
      (<span class="keyword">function</span>
      <span class="keywordsign">|</span> <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.printl <span class="string">"Got Pervasives.Exit"</span>
      <span class="keywordsign">|</span> exn <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt</span>.fail exn)
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    Despite the above code, the recommended way to write <code>Lwt.catch</code> is using
    the <code>try%lwt</code> syntactic sugar from the <a href=" Ppx_lwt.html"> <span class="acronym">PPX</span></a>. Here is an
    equivalent example:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">try%lwt</span> <span class="constructor">Lwt</span>.fail <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span>
    <span class="keyword">with</span> <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.printl <span class="string">"Got Pervasives.Exit"</span>
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    A particular advantage of the <span class="acronym">PPX</span> syntax is that it is not necessary to
    artificially insert a catch-all <code>exn&nbsp;-&gt;&nbsp;Lwt.fail&nbsp;exn</code> case. Like in the core
    language's <code>try</code> expression, the catch-all case is implied in <code>try%lwt</code>.
</p><p>

    <code>Lwt.catch</code> is a counterpart to <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> – <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> is for
    fulfillment, and <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a> is for rejection.
</p><p>

    As with <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, three promises are involved:
</p><ul>
<li><code>p_1</code>, the promise returned from applying <code>f&nbsp;()</code>.</li>
<li><code>p_2</code>, the promise returned from applying <code>h&nbsp;exn</code>.</li>
<li><code>p_3</code>, the promise returned by <code>Lwt.catch</code> itself.</li>
</ul><p>

    The remainder is (1) a precise description of how <code>p_3</code> is resolved, and
    (2) a warning about accidentally using ordinary <code>try</code> for exception handling
    in asynchronous code.
</p><p>

    <b>(1)</b> <code>Lwt.catch</code> first applies <code>f&nbsp;()</code>. It then returns <code>p_3</code> immediately.
    <code>p_3</code> starts out pending. It is resolved as follows:
</p><ul>
<li>If <code>f&nbsp;()</code> returned a promise <code>p_1</code>, and <code>p_1</code> becomes fulfilled, <code>p_3</code> is
      fulfilled with the same value.</li>
<li><code>p_1</code> can instead become rejected. There is one other possibility: <code>f&nbsp;()</code>
      itself raised an exception, instead of returning a promise. The behavior
      of <code>Lwt.catch</code> is the same whether <code>f&nbsp;()</code> raised an exception, or returned
      a promise that is later rejected with an exception. Let's call the
      exception <code>exn</code>.</li>
<li><code>h&nbsp;exn</code> is applied.</li>
<li><code>h&nbsp;exn</code> may return a promise, or might itself raise an exception. The
      first case is the interesting one, but the exception case is simple, so we
      cover the exception case first.</li>
<li>If <code>h&nbsp;exn</code> raises another exception <code>exn'</code>, <code>p_3</code> is rejected with <code>exn'</code>.</li>
<li>If <code>h&nbsp;exn</code> instead returns the promise <code>p_2</code>, <code>p_3</code> is effectively made
      into a reference to <code>p_2</code>. This means <code>p_3</code> and <code>p_2</code> have the same state,
      undergo the same state changes, and performing any operation one is
      equivalent to performing it on the other.</li>
</ul><p>

    <b>(2)</b> <b>Warning</b>: it may be tempting to write this code, which differs
    from the second example above only in that <code>try</code> is used instead of
    <code>try%lwt</code>:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">try</span> <span class="constructor">Lwt</span>.fail <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span>
    <span class="keyword">with</span> <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span> <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.printl <span class="string">"Got Pervasives.Exit"</span>
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    This does <em>not</em> handle the exception and does not print the message.
    Instead, it terminates the program with an unhandled <code>Pervasives.Exit</code>.
</p><p>

    This is because the call to <a href="Lwt.html#VALfail"><code>Lwt.fail</code></a> creates a rejected promise. The
    promise is still an ordinary OCaml value, though, and not a <em>raised</em>
    exception. So, <code>try</code> considers that code to have succeeded, and doesn't run
    the handler. When that rejected promise reaches <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>,
    it is <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> that raises the exception.
</p><p>

    Basically, the rule is: if the code inside <code>try</code> evaluates to a promise
    (has type <code>_&nbsp;Lwt.t</code>), replace <code>try</code> by <code>try%lwt</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.finalize" data-ml-identifier="finalize" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALfinalize">¶</a><span id="VALfinalize"><span class="keyword">val</span> finalize</span> : <code class="type">(unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ (unit ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.finalize&nbsp;f&nbsp;c</code> applies <code>f&nbsp;()</code>, which returns a promise, and then makes
    it so <code>c</code> (“cleanup”) will run when that promise is <a href=" #TYPEt">
    <em>resolved</em></a>.
</p><p>

    In other words, <code>c</code> runs no matter whether promise <code>f&nbsp;()</code> is fulfilled or
    rejected. As the names suggest, <code>Lwt.finalize</code> corresponds to the <code>finally</code>
    construct found in many programming languages, and <code>c</code> is typically used for
    cleaning up resources:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> file = <span class="constructor">Lwt_io</span>.(open_file <span class="constructor">Input</span> <span class="string">"code.ml"</span>) <span class="keyword">in</span>
    <span class="constructor">Lwt</span>.finalize
      (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
        <span class="keyword">let%lwt</span> content = <span class="constructor">Lwt_io</span>.read file <span class="keyword">in</span>
        <span class="constructor">Lwt_io</span>.print content)
      (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
        <span class="constructor">Lwt_io</span>.close file)
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    As with <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> and <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>, there is a syntactic sugar for
    <code>Lwt.finalize</code>, though it is not as often used:
</p><pre><code><span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> file = <span class="constructor">Lwt_io</span>.(open_file <span class="constructor">Input</span> <span class="string">"code.ml"</span>) <span class="keyword">in</span>
    <span class="keyword">begin</span>
      <span class="keyword">let%lwt</span> content = <span class="constructor">Lwt_io</span>.read file <span class="keyword">in</span>
      <span class="constructor">Lwt_io</span>.print content
    <span class="keyword">end</span>
    [%lwt.finally
      <span class="constructor">Lwt_io</span>.close file]
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    Also as with <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> and <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>, three promises are involved:
</p><ul>
<li><code>p_1</code>, the promise returned from applying <code>f&nbsp;()</code>.</li>
<li><code>p_2</code>, the promise returned from applying <code>c&nbsp;()</code>.</li>
<li><code>p_3</code>, the promise returned by <code>Lwt.finalize</code> itself.</li>
</ul><p>

    <code>p_3</code> is returned immediately. It starts out pending, and is resolved as
    follows:
</p><ul>
<li><code>f&nbsp;()</code> is applied. If it finishes, it will either return a promise <code>p_1</code>,
      or raise an exception.</li>
<li>If <code>f&nbsp;()</code> raises an exception, <code>p_1</code> is created artificially as a promise
      rejected with that exception. So, no matter how <code>f&nbsp;()</code> finishes, there is
      a promise <code>p_1</code> representing the outcome.</li>
<li>After <code>p_1</code> is resolved (fulfilled or rejected), <code>c&nbsp;()</code> is applied. This
      is meant to be the cleanup code.</li>
<li>If <code>c&nbsp;()</code> finishes, it will also either return a promise, <code>p_2</code>, or raise
      an exception.</li>
<li>If <code>c&nbsp;()</code> raises an exception, <code>p_2</code> is created artificially as a promise
      rejected with that exception. Again, no matter how <code>c&nbsp;()</code> finishes, there
      is a promise <code>p_2</code> representing the outcome of cleanup.</li>
<li>If <code>p_2</code> is fulfilled, <code>p_3</code> is resolved the same way <code>p_1</code> had been
      resolved. In other words, <code>p_1</code> is forwarded to <code>p_2</code> when cleanup is
      successful.</li>
<li>If <code>p_2</code> is rejected, <code>p_3</code> is rejected with the same exception. In other
      words, when cleanup fails, <code>p_3</code> is rejected. Note this means that if
      <em>both</em> the protected code and the cleanup fail, the cleanup exception
      has precedence.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.try_bind" data-ml-identifier="try_bind" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALtry_bind">¶</a><span id="VALtry_bind"><span class="keyword">val</span> try_bind</span> : 
  <code class="type">(unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ (α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ (exn ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.try_bind&nbsp;f&nbsp;g&nbsp;h</code> applies <code>f&nbsp;()</code>, and then makes it so that:
</p><ul>
<li><code>g</code> will run when promise <code>f&nbsp;()</code> is <a href=" #TYPEt"> <em>fulfilled</em></a>,</li>
<li><code>h</code> will run when promise <code>f&nbsp;()</code> is, alternatively, <a href=" #TYPEt">
      <em>rejected</em></a>.</li>
</ul><p>

    <code>Lwt.try_bind</code> is a generalized <a href="Lwt.html#VALfinalize"><code>Lwt.finalize</code></a>. The difference is that
    <code>Lwt.try_bind</code> runs different callbacks depending on <em>how</em> <code>f&nbsp;()</code> is
    resolved. This has two main implications:
</p><ul>
<li>The cleanup functions <code>g</code> and <code>h</code> each “know” whether <code>f&nbsp;()</code> was fulfilled
      or rejected.</li>
<li>The cleanup functions <code>g</code> and <code>h</code> are passed the value <code>f&nbsp;()</code> was
      fulfilled with, and, respectively, the exception <code>f&nbsp;()</code> was rejected
      with.</li>
</ul><p>

    The rest is a detailed description of the promises involved.
</p><p>

    As with <a href="Lwt.html#VALfinalize"><code>Lwt.finalize</code></a> and the several preceding functions, three promises
    are involved.
</p><ul>
<li><code>p_1</code> is the promise returned from applying <code>f&nbsp;()</code>.</li>
<li><code>p_2</code> is the promise returned from applying <code>h</code> or <code>g</code>, depending on which
      one is chosen.</li>
<li><code>p_3</code> is the promise returned by <code>Lwt.try_bind</code> itself.</li>
</ul><p>

    <code>Lwt.try_bind</code> returns <code>p_3</code> immediately. <code>p_3</code> starts out pending, and is
    resolved as follows:
</p><ul>
<li><code>f&nbsp;()</code> is applied. If it finishes, it either returns <code>p_1</code>, or raises an
      exception.</li>
<li>If <code>f&nbsp;()</code> raises an exception, <code>p_1</code> is created artificially as a promise
      rejected with that exception. So, no matter how <code>f&nbsp;()</code> finishes, there is
      a promise <code>p_1</code> representing the outcome.</li>
<li>If <code>p_1</code> is fulfilled, <code>g</code> is applied to the value <code>p_1</code> is fulfilled
      with.</li>
<li>If <code>p_1</code> is rejected, <code>h</code> is applied to the exception <code>p_1</code> is rejected
      with.</li>
<li>So, in either case, a callback is applied. The rest of the procedure is
      the same no matter which callback was chosen, so we will refer to it as
      “the callback.”</li>
<li>If the callback finishes, it either returns <code>p_2</code>, or raises an exception.</li>
<li>If the callback raises an exception, <code>p_3</code> is rejected with that
      exception.</li>
<li>If the callback returns <code>p_2</code>, <code>p_3</code> is effectively made into an reference
      to <code>p_2</code>. They have the same state, including any state changes, and
      performing any operation on one is equivalent to performing it on the
      other.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.async" data-ml-identifier="async" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALasync">¶</a><span id="VALasync"><span class="keyword">val</span> async</span> : <code class="type">(unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.async&nbsp;f</code> applies <code>f&nbsp;()</code>, which returns a promise, and then makes it so
    that if the promise is <a href=" #TYPEt"> <em>rejected</em></a>, the exception is passed to
    <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.
</p><p>

    In addition, if <code>f&nbsp;()</code> raises an exception, it is also passed to
    <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.
</p><p>

    <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a> typically prints an error message and
    terminates the program.
</p><p>

    <code>Lwt.async</code> is misleadingly named. Itself, it has nothing to do with
    asynchronous execution. It's actually a safety function for making Lwt
    programs more debuggable.
</p><p>

    For example, take this program, which prints messages in a loop, while
    waiting for one line of user input:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> <span class="keyword">rec</span> show_nag () : _ <span class="constructor">Lwt</span>.t =
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_io</span>.printl <span class="string">"Please enter a line"</span> <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 1. <span class="keyword">in</span>
    show_nag ()
  <span class="keyword">in</span>
  ignore (show_nag ());     <span class="comment">(* Bad – see note for (1)! *)</span>

  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> line = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl line
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    If one of the <span class="acronym">I/O</span> operations in <code>show_nag</code> were to fail, the promise
    representing the whole loop would get rejected. However, since we are
    ignoring that promise at <b>(1)</b>, we never find out about the rejection. If
    this failure and resulting rejection represents a bug in the program, we
    have a harder time finding out about the bug.
</p><p>

    A safer version differs only in using <code>Lwt.async</code> instead of
    <code>Pervasives.ignore</code>:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> <span class="keyword">rec</span> show_nag () : _ <span class="constructor">Lwt</span>.t =
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_io</span>.printl <span class="string">"Please enter a line"</span> <span class="keyword">in</span>
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 1. <span class="keyword">in</span>
    show_nag ()
  <span class="keyword">in</span>
  <span class="constructor">Lwt</span>.async (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> show_nag ());

  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> line = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl line
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    In this version, if <span class="acronym">I/O</span> in <code>show_nag</code> fails with an exception, the exception
    is printed by <code>Lwt.async</code>, and then the program exits.
</p><p>

    The general rule for when to use <code>Lwt.async</code> is:
</p><ul>
<li>Promises which are <em>not</em> passed <em>to</em> <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>,
      <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a>, etc., are <b>top-level</b> promises.</li>
<li>One top-level promise is passed to <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>, as can be seen in most
      examples in this manual.</li>
<li>Every other top-level promise should be wrapped in <code>Lwt.async</code>.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.async_exception_hook" data-ml-identifier="async_exception_hook" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALasync_exception_hook">¶</a><span id="VALasync_exception_hook"><span class="keyword">val</span> async_exception_hook</span> : <code class="type">(exn ⟶ unit) Pervasives.ref</code></pre><div class="info "><p>
Reference to a function, to be called on an "unhandled" exception.
</p><p>

    This reference is used by <a href="Lwt.html#VALasync"><code>Lwt.async</code></a>, <a href="Lwt.html#VALon_cancel"><code>Lwt.on_cancel</code></a>, <a href="Lwt.html#VALon_success"><code>Lwt.on_success</code></a>,
    <a href="Lwt.html#VALon_failure"><code>Lwt.on_failure</code></a>, <a href="Lwt.html#VALon_termination"><code>Lwt.on_termination</code></a>, <a href="Lwt.html#VALon_any"><code>Lwt.on_any</code></a>, and the deprecated
    <a href="Lwt.html#VALignore_result"><code>Lwt.ignore_result</code></a>.
</p><p>

    The initial, default implementation prints the exception, then terminates
    the process with non-zero exit status, as if the exception had reached the
    top level of the program:
</p><pre><code><span class="keyword">let</span> () = <span class="constructor">Lwt</span>.async (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt</span>.fail <span class="constructor">Pervasives</span>.<span class="constructor">Exit</span>)

<span class="comment">(* ocamlfind opt -linkpkg -package lwt code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    produces in the output:
</p><pre class="verbatim">Fatal error: exception Pervasives.Exit</pre><p>

    If you are writing an application, you are welcome to reassign the
    reference, and replace the function with something more appropriate for your
    needs.
</p><p>

    If you are writing a library, you should leave this reference alone. Its
    behavior should be determined by the application.
</p></div>

</div><h2 id="2_Concurrency"><a class="anchor" href="#2_Concurrency">¶</a>Concurrency</h2><h3 id="3_Multiplewait"><a class="anchor" href="#3_Multiplewait">¶</a>Multiple wait</h3><div data-ml-fq-identifier="Lwt.join" data-ml-identifier="join" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALjoin">¶</a><span id="VALjoin"><span class="keyword">val</span> join</span> : <code class="type">(unit <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.join&nbsp;ps</code> returns a promise that is pending until <em>all</em> promises in
    the list <code>ps</code> become <a href=" #TYPEt"> <em>resolved</em></a>.
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p_1 =
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 3. <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl <span class="string">"Three seconds elapsed"</span>
  <span class="keyword">in</span>

  <span class="keyword">let</span> p_2 =
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 5. <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl <span class="string">"Five seconds elapsed"</span>
  <span class="keyword">in</span>

  <span class="keyword">let</span> p_3 = <span class="constructor">Lwt</span>.join [p_1; p_2] <span class="keyword">in</span>
  <span class="constructor">Lwt_main</span>.run p_3

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    If all of the promises in <code>ps</code> become fulfilled, <code>Lwt.join&nbsp;ps</code> is also
    fulfilled. Otherwise, if at least one promise in <code>ps</code> becomes rejected,
    <code>Lwt.join&nbsp;ps</code> is rejected with the same exception as one such promise,
    chosen arbitrary.
</p></div>

</div><h3 id="3_Racing"><a class="anchor" href="#3_Racing">¶</a>Racing</h3><div data-ml-fq-identifier="Lwt.pick" data-ml-identifier="pick" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALpick">¶</a><span id="VALpick"><span class="keyword">val</span> pick</span> : <code class="type">(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.pick&nbsp;ps</code> returns a promise that is pending until <em>one</em> promise in
    the list <code>ps</code> becomes <a href=" #TYPEt"> <em>resolved</em></a>.
</p><p>

    When at least one promise in <code>ps</code> is resolved, <code>Lwt.pick</code> tries to cancel
    all other promises that are still pending, using <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>.
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> echo =
    <span class="keyword">let%lwt</span> line = <span class="constructor">Lwt_io</span>.(read_line stdin) <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl line
  <span class="keyword">in</span>

  <span class="keyword">let</span> timeout = <span class="constructor">Lwt_unix</span>.sleep 5. <span class="keyword">in</span>

  <span class="constructor">Lwt_main</span>.run (<span class="constructor">Lwt</span>.pick [echo; timeout])

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    If the first promise in <code>ps</code> to become resolved is fulfilled, the result
    promise <code>p</code> is also fulfilled, with the same value. Likewise, if the first
    promise in <code>ps</code> to become resolved is rejected, <code>p</code> is rejected with the
    same exception.
</p><p>

    It's possible for multiple promises in <code>ps</code> to become resolved
    simultaneously. This happens most often when some promises <code>ps</code> are already
    resolved at the time <code>Lwt.pick</code> is called.
</p><p>

    In that case, if at least one of the promises is rejected, the result
    promise <code>p</code> is rejected with the same exception as one such promise, chosen
    arbitrarily. If all promises are fulfilled, <code>p</code> is fulfilled with the value
    of one of the promises, also chosen arbitrarily.
</p><p>

    The remaining functions in this section are variations on <code>Lwt.pick</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.choose" data-ml-identifier="choose" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALchoose">¶</a><span id="VALchoose"><span class="keyword">val</span> choose</span> : <code class="type">(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.choose&nbsp;ps</code> is the same as <a href="Lwt.html#VALpick"><code>Lwt.pick</code></a><code>&nbsp;ps</code>, except that it does not try
    to cancel pending promises in <code>ps</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.npick" data-ml-identifier="npick" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALnpick">¶</a><span id="VALnpick"><span class="keyword">val</span> npick</span> : <code class="type">(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ (α list) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.npick&nbsp;ps</code> is similar to <a href="Lwt.html#VALpick"><code>Lwt.pick</code></a><code>&nbsp;ps</code>, the difference being that
    when multiple promises in <code>ps</code> are fulfilled simultaneously (and none are
    rejected), the result promise is fulfilled with the <em>list</em> of values the
    promises were fulfilled with.
</p><p>

    When at least one promise is rejected, <code>Lwt.npick</code> still rejects the result
    promise with the same exception.
</p></div>

</div><div data-ml-fq-identifier="Lwt.nchoose" data-ml-identifier="nchoose" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALnchoose">¶</a><span id="VALnchoose"><span class="keyword">val</span> nchoose</span> : <code class="type">(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ (α list) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.nchoose&nbsp;ps</code> is the same as <a href="Lwt.html#VALnpick"><code>Lwt.npick</code></a><code>&nbsp;ps</code>, except that it does not
    try to cancel pending promises in <code>ps</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.nchoose_split" data-ml-identifier="nchoose_split" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALnchoose_split">¶</a><span id="VALnchoose_split"><span class="keyword">val</span> nchoose_split</span> : <code class="type">(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list ⟶ (α list * [(α <a href="Lwt.html#TYPEt">Lwt.t</a>) list]) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.nchoose_split&nbsp;ps</code> is the same as <a href="Lwt.html#VALnchoose"><code>Lwt.nchoose</code></a><code>&nbsp;ps</code>, except that when
    multiple promises in <code>ps</code> are fulfilled simultaneously (and none are
    rejected), the result promise is fulfilled with <em>both</em> the list of values
    of the fulfilled promises, and the list of promises that are still
    pending.
</p></div>

</div><h2 id="2_Cancelation"><a class="anchor" href="#2_Cancelation">¶</a>Cancelation</h2><div data-ml-fq-identifier="Lwt.Canceled" data-ml-identifier="Canceled" data-ml-kind="exception" class="item"><pre><a class="anchor" href="#EXCEPTIONCanceled">¶</a><span id="EXCEPTIONCanceled"><span class="keyword">exception</span> Canceled</span></pre>
<div class="info "><p>
Canceled promises are those rejected with this exception, <code>Lwt.Canceled</code>.
    See <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.cancel" data-ml-identifier="cancel" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALcancel">¶</a><span id="VALcancel"><span class="keyword">val</span> cancel</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.cancel&nbsp;p</code> attempts to <em>cancel</em> the pending promise <code>p</code>, without
    needing access to its resolver.
</p><p>

    A <b>canceled</b> promise is one that has been rejected with exception
    <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a>.
</p><p>

    There are straightforward ways to make promises canceled. One could create a
    promise that <em>starts out</em> canceled, with <a href="Lwt.html#VALfail"><code>Lwt.fail</code></a><code>&nbsp;Lwt.Canceled</code>. It's
    also possible to <em>make</em> a promise canceled through its resolver, by
    calling <a href="Lwt.html#VALwakeup_later_exn"><code>Lwt.wakeup_later_exn</code></a><code>&nbsp;r&nbsp;Lwt.Canceled</code>.
</p><p>

    This function, <code>Lwt.cancel</code>, provides another method, which can cancel
    pending promises <em>without</em> going through their resolvers – it acts
    directly on promises.
</p><p>

    Like any other promise rejection, the canceled state of a promise is
    propagated “forwards” by <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a>, etc., as described in the
    documentation of those functions.
</p><p>

    <b>Cancelation</b> is a separate phase, triggered only by <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>, that
    searches <em>backwards</em>, strating from <code>p</code>, for promises to reject with
    <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a>. Once those promises are found, they are canceled, and then
    ordinary, forwards rejection propagation takes over.
</p><p>

    All of this will be made precise, but first let's have an example:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> p =
    <span class="keyword">let%lwt</span> () = <span class="constructor">Lwt_unix</span>.sleep 5. <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printl <span class="string">"Slept five seconds"</span>
  <span class="keyword">in</span>

  <span class="constructor">Lwt</span>.cancel p;

  <span class="constructor">Lwt_main</span>.run p

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    At the time <code>Lwt.cancel</code> is called, <code>p</code> “depends” on the <code>sleep</code> promise
    (the <code>printl</code> is not yet called, so its promise hasn't been created).
</p><p>

    So, <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a> recursively tries to cancel the <code>sleep</code> promise. That is
    an example of the backwards search. The <code>sleep</code> promise is a pending promise
    that doesn't depend on anything, so backwards search stops at it. The state
    of the <code>sleep</code> promise is set to <em>rejected</em> with <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a>.
</p><p>

    <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> then propagates the rejection forwards to <code>p</code>, so <code>p</code> also
    becomes canceled.
</p><p>

    Eventually, this rejection reaches <a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a>, which raises the
    <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a> as an ordinary exception. The <code>sleep</code> does not complete, and
    the <code>printl</code> is never started.
</p><p>

    Promises, like the <code>sleep</code> promise above, that can be rejected by
    <code>Lwt.cancel</code> are <b>cancelable</b>. Most promises in Lwt are either cancelable,
    or depend on cancelable promises. The functions <a href="Lwt.html#VALwait"><code>Lwt.wait</code></a> and
    <a href="Lwt.html#VALno_cancel"><code>Lwt.no_cancel</code></a> create promises that are <em>not</em> cancelable.
</p><p>

    The rest is a detailed description of how the <code>Lwt.cancel</code> backwards search
    works.
</p><ul>
<li>If <code>p</code> is already resolved, <code>Lwt.cancel</code> does nothing.</li>
<li>If <code>p</code> was created by <a href="Lwt.html#VALwait"><code>Lwt.wait</code></a> or <a href="Lwt.html#VALno_cancel"><code>Lwt.no_cancel</code></a>, <code>Lwt.cancel</code> does
      nothing.</li>
<li>If <code>p</code> was created by <a href="Lwt.html#VALtask"><code>Lwt.task</code></a> or <a href="Lwt.html#VALprotected"><code>Lwt.protected</code></a>, <code>Lwt.cancel</code>
      rejects it with <code>Lwt.Canceled</code>. This rejection then propagates normally
      through any Lwt calls that depend on <code>p</code>. Most <span class="acronym">I/O</span> promises are internally
      created by calling <a href="Lwt.html#VALtask"><code>Lwt.task</code></a>.</li>
<li>Suppose <code>p_3</code> was returned by <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, <a href="Lwt.html#VALmap"><code>Lwt.map</code></a>, <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>,
      <a href="Lwt.html#VALfinalize"><code>Lwt.finalize</code></a>, or <a href="Lwt.html#VALtry_bind"><code>Lwt.try_bind</code></a>. Then, see those functions for the
      naming of the other promises involved. If <code>p_3</code> is pending, then either
      <code>p_1</code> is pending, or <code>p_2</code> is pending. <code>Lwt.cancel&nbsp;p_3</code> then tries
      recursively to cancel whichever of these two is still pending. If that
      succeeds, <code>p_3</code> <em>may</em> be canceled later by the normal propagation of
      rejection.</li>
<li>Suppose <code>p</code> was returned by <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a>, <a href="Lwt.html#VALpick"><code>Lwt.pick</code></a>, or similar function,
      which was applied to the promise list <code>ps</code>. <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a> then recursively
      tries to cancel each promise in <code>ps</code>. If one of those cancelations
      succeeds, <code>p</code> <em>may</em> be canceled later by the normal propagation of
      rejection.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.on_cancel" data-ml-identifier="on_cancel" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALon_cancel">¶</a><span id="VALon_cancel"><span class="keyword">val</span> on_cancel</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (unit ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.on_cancel&nbsp;p&nbsp;f</code> makes it so that <code>f</code> will run when <code>p</code> becomes
    <a href=" #EXCEPTIONCanceled"> <em>canceled</em></a>.
</p><p>

    Callbacks scheduled with <code>on_cancel</code> are guaranteed to run before any other
    callbacks that are triggered by rejection, such as those added by
    <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>.
</p><p>

    Note that this does not interact directly with the <em>cancelation</em>
    mechanism, the backwards search described in <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>. For example,
    manually rejecting a promise with <a href="Lwt.html#EXCEPTIONCanceled"><code>Lwt.Canceled</code></a> is sufficient to trigger
    <code>f</code>.
</p><p>

    <code>f</code> should not raise exceptions. If it does, they are passed to
    <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>, which terminates the process by default.
</p></div>

</div><div data-ml-fq-identifier="Lwt.protected" data-ml-identifier="protected" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALprotected">¶</a><span id="VALprotected"><span class="keyword">val</span> protected</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.protected&nbsp;p</code> creates a <a href=" #VALcancel"> cancelable</a> promise <code>p'</code> with
    the same state as <code>p</code>. However, cancelation, the backwards search described
    in <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>, stops at <code>p'</code>, and does not continue to <code>p</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.no_cancel" data-ml-identifier="no_cancel" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALno_cancel">¶</a><span id="VALno_cancel"><span class="keyword">val</span> no_cancel</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.no_cancel&nbsp;p</code> creates a non-<a href=" #VALcancel">cancelable</a> promise <code>p'</code>,
    with the same state as <code>p</code>. Cancelation, the backwards search described in
    <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>, stops at <code>p'</code>, and does not continue to <code>p</code>.
</p><p>

    Note that <code>p'</code> can still be canceled if <code>p</code> is canceled. <code>Lwt.no_cancel</code>
    only prevents cancelation of <code>p</code> and <code>p'</code> through <code>p'</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wait" data-ml-identifier="wait" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwait">¶</a><span id="VALwait"><span class="keyword">val</span> wait</span> : <code class="type">unit ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> * α <a href="Lwt.html#TYPEu">Lwt.u</a></code></pre><div class="info "><p>
<code>Lwt.wait</code> is the same as <a href="Lwt.html#VALtask"><code>Lwt.task</code></a>, except the resulting promise <code>p</code> is
    <em>not</em> <a href=" #VALcancel"> cancelable</a>.
</p><p>

    This is significant, because it means <code>p</code> created by <code>Lwt.wait</code> can <em>only</em>
    be resolved through its paired resolver.
</p><p>

    In contrast, promises returned by <a href="Lwt.html#VALtask"><code>Lwt.task</code></a> can additionally be resolved
    by canceling them directly with <a href="Lwt.html#VALcancel"><code>Lwt.cancel</code></a>.
</p></div>

</div><h2 id="2_Convenience"><a class="anchor" href="#2_Convenience">¶</a>Convenience</h2><h3 id="3_Callbackhelpers"><a class="anchor" href="#3_Callbackhelpers">¶</a>Callback helpers</h3><div data-ml-fq-identifier="Lwt.map" data-ml-identifier="map" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALmap">¶</a><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(α ⟶ β) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.map&nbsp;f&nbsp;p_1</code> is similar to <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a><code>&nbsp;p_1&nbsp;f</code>, but <code>f</code> is not expected
    to return a promise.
</p><p>

    This function is more convenient that <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> when <code>f</code> inherently does
    not return a promise. An example is <code>Pervasives.int_of_string</code>:
</p><pre><code><span class="keyword">let</span> read_int : unit <span class="keywordsign">-&gt;</span> int <span class="constructor">Lwt</span>.t = <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
  <span class="constructor">Lwt</span>.map
    int_of_string
    <span class="constructor">Lwt_io</span>.(read_line stdin)

<span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="keyword">let%lwt</span> number = read_int () <span class="keyword">in</span>
    <span class="constructor">Lwt_io</span>.printf <span class="string">"%i\n"</span> number
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    By comparison, the <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> version is more awkward:
</p><pre><code><span class="keyword">let</span> read_int : unit <span class="keywordsign">-&gt;</span> int <span class="constructor">Lwt</span>.t = <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
  <span class="constructor">Lwt</span>.bind
    <span class="constructor">Lwt_io</span>.(read_line stdin)
    (<span class="keyword">fun</span> line <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt</span>.return (int_of_string line))
</code></pre><p>

    As with <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, sequences of calls to <code>Lwt.map</code> result in excessive
    indentation and parentheses. The recommended syntactic sugar for avoiding
    this is the <a href=" #VAL(>|=)"> <code>&gt;|=</code></a> operator, which comes from module
    <code>Lwt.Infix</code>:
</p><pre><code><span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

<span class="keyword">let</span> read_int : unit <span class="keywordsign">-&gt;</span> int <span class="constructor">Lwt</span>.t = <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
  <span class="constructor">Lwt_io</span>.(read_line stdin) &gt;|= int_of_string
</code></pre><p>

    The detailed operation follows. For consistency with the promises in
    <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, the <em>two</em> promises involved are named <code>p_1</code> and <code>p_3</code>:
</p><ul>
<li><code>p_1</code> is the promise passed to <code>Lwt.map</code>.</li>
<li><code>p_3</code> is the promise returned by <code>Lwt.map</code>.</li>
</ul><p>

    <code>Lwt.map</code> returns a promise <code>p_3</code>. <code>p_3</code> starts out pending. It is resolved
    as follows:
</p><ul>
<li><code>p_1</code> may be, or become, resolved. In that case, by definition, it will
      become fulfilled or rejected. Fulfillment is the interesting case, but the
      behavior on rejection is simpler, so we focus on rejection first.</li>
<li>When <code>p_1</code> becomes rejected, <code>p_3</code> is rejected with the same exception.</li>
<li>When <code>p_1</code> instead becomes fulfilled, call the value it is fulfilled with
      <code>v</code>.</li>
<li><code>f&nbsp;v</code> is applied. If this finishes, it may either return another value, or
      raise an exception.</li>
<li>If <code>f&nbsp;v</code> returns another value <code>v'</code>, <code>p_3</code> is fulfilled with <code>v'</code>.</li>
<li>If <code>f&nbsp;v</code> raises exception <code>exn</code>, <code>p_3</code> is rejected with <code>exn</code>.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.on_success" data-ml-identifier="on_success" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALon_success">¶</a><span id="VALon_success"><span class="keyword">val</span> on_success</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.on_success&nbsp;p&nbsp;f</code> makes it so that <code>f</code> will run when <code>p</code> is <a href=" #TYPEt">
    <em>fulfilled</em></a>.
</p><p>

    It is similar to <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>, except no new promises are created. <code>f</code> is a
    plain, arbitrary function attached to <code>p</code>, to perform some side effect.
</p><p>

    If <code>f</code> raises an exception, it is passed to <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.
    By default, this will terminate the process.
</p></div>

</div><div data-ml-fq-identifier="Lwt.on_failure" data-ml-identifier="on_failure" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALon_failure">¶</a><span id="VALon_failure"><span class="keyword">val</span> on_failure</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (exn ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.on_failure&nbsp;p&nbsp;f</code> makes it so that <code>f</code> will run when <code>p</code> is <a href=" #TYPEt">
    <em>rejected</em></a>.
</p><p>

    It is similar to <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>, except no new promises are created.
</p><p>

    If <code>f</code> raises an exception, it is passed to <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.
    By default, this will terminate the process.
</p></div>

</div><div data-ml-fq-identifier="Lwt.on_termination" data-ml-identifier="on_termination" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALon_termination">¶</a><span id="VALon_termination"><span class="keyword">val</span> on_termination</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (unit ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.on_termination&nbsp;p&nbsp;f</code> makes it so that <code>f</code> will run when <code>p</code> is
    <a href=" #TYPEt"> <em>resolved</em></a> – that is, fulfilled <em>or</em> rejected.
</p><p>

    It is similar to <a href="Lwt.html#VALfinalize"><code>Lwt.finalize</code></a>, except no new promises are created.
</p><p>

    If <code>f</code> raises an exception, it is passed to <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.
    By default, this will terminate the process.
</p></div>

</div><div data-ml-fq-identifier="Lwt.on_any" data-ml-identifier="on_any" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALon_any">¶</a><span id="VALon_any"><span class="keyword">val</span> on_any</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ unit) ⟶ (exn ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.on_any&nbsp;p&nbsp;f&nbsp;g</code> makes it so that:
</p><ul>
<li><code>f</code> will run when <code>p</code> is <a href=" #TYPEt"> <em>fulfilled</em></a>,</li>
<li><code>g</code> will run when <code>p</code> is, alternatively, <a href=" #TYPEt"> <em>rejected</em></a>.</li>
</ul><p>

    It is similar to <a href="Lwt.html#VALtry_bind"><code>Lwt.try_bind</code></a>, except no new promises are created.
</p><p>

    If <code>f</code> or <code>g</code> raise an exception, the exception is passed to
    <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>. By default, this will terminate the
    process.
</p></div>

</div><h3 id="3_Infixoperators"><a class="anchor" href="#3_Infixoperators">¶</a>Infix operators</h3><div data-ml-fq-identifier="Lwt.Infix" data-ml-identifier="Infix" data-ml-kind="module" class="item"><pre><a class="anchor" href="#MODULEInfix">¶</a><span id="MODULEInfix" class="keyword">module</span> Infix</pre><div class="info module top"><p>
This module provides several infix operators for making programming with
    Lwt more convenient.
</p><p>

    To use it, open <code>Lwt.Infix</code>.
</p><p>

    Of the operators declared in this module, only <code>&gt;|=</code> is recommended for new
    code. The only other commonly-used operator is <code>&gt;&gt;=</code>.
</p></div>
</div><div data-ml-fq-identifier="Lwt.Infix.(>>=)" data-ml-identifier="Infix.(>>=)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(>>=)">¶</a><span id="Infix.VAL(>>=)"><span class="keyword">val</span> Infix.(&gt;&gt;=)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>p&nbsp;&gt;&gt;=&nbsp;f</code> is the same as <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a><code>&nbsp;p&nbsp;f</code>. It requires <code>Lwt.Infix</code> to be
      opened in scope:
</p><pre><code><span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

<span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run
    (<span class="constructor">Lwt_io</span>.(read_line stdin) &gt;&gt;= <span class="constructor">Lwt_io</span>.printl)

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

      It is recommended to use the <span class="acronym">PPX</span> <code>let%lwt</code> syntax instead. This operator
      is the next-best choice. It is frequently found while reading existing
      Lwt code.
</p></div></div><div data-ml-fq-identifier="Lwt.Infix.(>|=)" data-ml-identifier="Infix.(>|=)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(>|=)">¶</a><span id="Infix.VAL(>|=)"><span class="keyword">val</span> Infix.(&gt;|=)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ β) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>p&nbsp;&gt;|=&nbsp;f</code> is the same as <a href="Lwt.html#VALmap"><code>Lwt.map</code></a><code>&nbsp;f&nbsp;p</code>. It requires <code>Lwt.Infix</code> to be
      opened in scope.
</p><pre><code><span class="keyword">open</span> <span class="constructor">Lwt</span>.<span class="constructor">Infix</span>

<span class="keyword">let</span> () =
  <span class="constructor">Lwt_main</span>.run
    (<span class="constructor">Lwt_io</span>.(read_line stdin) &gt;|= ignore)

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre></div></div><div data-ml-fq-identifier="Lwt.Infix.(<&amp;>)" data-ml-identifier="Infix.(<&amp;>)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(<&amp;>)">¶</a><span id="Infix.VAL(<&amp;>)"><span class="keyword">val</span> Infix.(&lt;&amp;&gt;)</span> : <code class="type">unit <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>p1&nbsp;&lt;&amp;&gt;&nbsp;p2</code> is the same as <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a><code>&nbsp;[p1;&nbsp;p2]</code>. It requires <code>Lwt.Infix</code>
      to be opened in scope.
</p><p>

      Unlike with <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> and <a href="Lwt.html#VALmap"><code>Lwt.map</code></a>, there are no problems with
      explicit <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a> syntax, so using this operator is not recommended.
</p></div></div><div data-ml-fq-identifier="Lwt.Infix.(<?>)" data-ml-identifier="Infix.(<?>)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(<?>)">¶</a><span id="Infix.VAL(<?>)"><span class="keyword">val</span> Infix.(&lt;?&gt;)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>p1&nbsp;&lt;?&gt;&nbsp;p2</code> is the same as <a href="Lwt.html#VALchoose"><code>Lwt.choose</code></a><code>&nbsp;[p1;&nbsp;p2]</code>. It requires
      <code>Lwt.Infix</code> to be opened in scope.
</p><p>

      Unlike with <code>Lwt,bind</code> and <a href="Lwt.html#VALjoin"><code>Lwt.join</code></a>, there are no problems with
      explicit <a href="Lwt.html#VALchoose"><code>Lwt.choose</code></a> syntax, so using this operator is not
      recommended.
</p><p>

      Futhermore, most users actually need <a href="Lwt.html#VALpick"><code>Lwt.pick</code></a> instead of
      <a href="Lwt.html#VALchoose"><code>Lwt.choose</code></a>.
</p></div></div><div data-ml-fq-identifier="Lwt.Infix.(=<<)" data-ml-identifier="Infix.(=<<)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(=<<)">¶</a><span id="Infix.VAL(=<<)"><span class="keyword">val</span> Infix.(=&lt;&lt;)</span> : <code class="type">(α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>f&nbsp;=&lt;&lt;&nbsp;p</code> is the same as <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a><code>&nbsp;p&nbsp;f</code>. It requires <code>Lwt.Infix</code> to be
      opened in scope.
</p><p>

      This operator is obscure and its use is discouraged. It is the same as
      <code>p&nbsp;&gt;&gt;=&nbsp;f</code>.
</p></div></div><div data-ml-fq-identifier="Lwt.Infix.(=|<)" data-ml-identifier="Infix.(=|<)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#Infix.VAL(=|<)">¶</a><span id="Infix.VAL(=|<)"><span class="keyword">val</span> Infix.(=|&lt;)</span> : <code class="type">(α ⟶ β) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>f&nbsp;=|&lt;&nbsp;p</code> is the same as <a href="Lwt.html#VALmap"><code>Lwt.map</code></a><code>&nbsp;f&nbsp;p</code>. It requires <code>Lwt.Infix</code> to be
      opened in scope.
</p><p>

      This operator is obscure and its use is discouraged. It is the same as
      <code>p&nbsp;&gt;|=&nbsp;f</code>.
</p></div>
</div><h3 id="3_Preallocatedpromises"><a class="anchor" href="#3_Preallocatedpromises">¶</a>Pre-allocated promises</h3><div data-ml-fq-identifier="Lwt.return_unit" data-ml-identifier="return_unit" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_unit">¶</a><span id="VALreturn_unit"><span class="keyword">val</span> return_unit</span> : <code class="type">unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return_unit</code> is defined as <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;()</code>, but this definition is
    evaluated only once, during initialization of module <code>Lwt</code>, at the beginning
    of your program.
</p><p>

    This means the promise is allocated only once. By contrast, each time
    <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;()</code> is evaluated, it allocates a new promise.
</p><p>

    It is recommended to use <code>Lwt.return_unit</code> only where you know the
    allocations caused by an instance of <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;()</code> are a performance
    bottleneck. Generally, the cost of <span class="acronym">I/O</span> tends to dominate the cost of
    <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;()</code> anyway.
</p><p>

    In future Lwt, we hope to perform this optimization, of using a single,
    pre-allocated promise, automatically, wherever <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;()</code> is
    written.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_none" data-ml-identifier="return_none" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_none">¶</a><span id="VALreturn_none"><span class="keyword">val</span> return_none</span> : <code class="type">(α option) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return_none</code> is like <a href="Lwt.html#VALreturn_unit"><code>Lwt.return_unit</code></a>, but for
    <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;None</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_nil" data-ml-identifier="return_nil" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_nil">¶</a><span id="VALreturn_nil"><span class="keyword">val</span> return_nil</span> : <code class="type">(α list) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return_nil</code> is like <a href="Lwt.html#VALreturn_unit"><code>Lwt.return_unit</code></a>, but for <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;[]</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_true" data-ml-identifier="return_true" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_true">¶</a><span id="VALreturn_true"><span class="keyword">val</span> return_true</span> : <code class="type">bool <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return_true</code> is like <a href="Lwt.html#VALreturn_unit"><code>Lwt.return_unit</code></a>, but for
    <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;true</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_false" data-ml-identifier="return_false" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_false">¶</a><span id="VALreturn_false"><span class="keyword">val</span> return_false</span> : <code class="type">bool <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.return_false</code> is like <a href="Lwt.html#VALreturn_unit"><code>Lwt.return_unit</code></a>, but for
    <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;false</code>.
</p></div>

</div><h3 id="3_Resulttype"><a class="anchor" href="#3_Resulttype">¶</a>Result type</h3><div data-ml-fq-identifier="Lwt.result" data-ml-identifier="result" data-ml-kind="type" class="item"><pre><a class="anchor" href="#TYPEresult">¶</a><span id="TYPEresult"><span class="keyword">type</span> <code class="type">+α</code> result</span> = <code class="type">(α, exn) Result.result</code> </pre>
<div class="info "><p>
Representation of the content of a resolved promise of type
    <a href="Lwt.html#TYPEt"><code>α&nbsp;Lwt.t</code></a>.
</p><p>

    This type is effectively
</p><pre><code><span class="keyword">type</span> +<span class="keywordsign">'</span>a <span class="constructor">Lwt</span>.result =
  <span class="keywordsign">|</span> <span class="constructor">Ok</span> <span class="keyword">of</span> <span class="keywordsign">'</span>a
  <span class="keywordsign">|</span> <span class="constructor">Error</span> <span class="keyword">of</span> exn
</code></pre><p>

    or, on OCaml 4.02:
</p><pre><code><span class="keyword">type</span> +<span class="keywordsign">'</span>a <span class="constructor">Lwt</span>.result =
  <span class="keywordsign">|</span> <span class="constructor">Result</span>.<span class="constructor">Ok</span> <span class="keyword">of</span> <span class="keywordsign">'</span>a
  <span class="keywordsign">|</span> <span class="constructor">Result</span>.<span class="constructor">Error</span> <span class="keyword">of</span> exn
</code></pre><p>

    A resolved promise of type <a href="Lwt.html#TYPEt"><code>α&nbsp;Lwt.t</code></a> is either fulfilled with a value of
    type <code>α</code>, or rejected with an exception.
</p><p>

    This corresponds to the cases of a
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult"><code>(α,&nbsp;exn)Pervasives.result</code></a>:
    fulfilled corresponds to <code>Ok&nbsp;of&nbsp;α</code>, and rejected corresponds to
    <code>Error&nbsp;of&nbsp;exn</code>.
</p><p>

    It's important to note that this type constructor, <code>Lwt.result</code>, is
    different from <code>Pervasives.result</code>. It is a specialization of
    <code>Pervasives.result</code> so that the <code>Error</code> constructor always carries <code>exn</code>.
</p><p>

    For Lwt programming with <code>result</code> where the <code>Error</code> constructor can carry
    arbitrary error types, see module <a href="Lwt_result.html"><code>Lwt_result</code></a>.
</p><p>

    The naming conflict between <code>Lwt.result</code> and <code>Pervasives.result</code> is an
    unfortunate historical accident. <code>Pervasives.result</code> did not exist when
    <code>Lwt.result</code> was created.
</p><p>

    The type <code>Result.result</code> is equivalent to <code>Pervasives.result</code> starting from
    OCaml 4.03. If you need compatibility with OCaml 4.02, refer to
    <code>Pervasives.result</code> as <code>Result.result</code>, and prefix the constructor names
    with <code>Result</code>, as shown in the second example.
</p></div>


</div><div data-ml-fq-identifier="Lwt.of_result" data-ml-identifier="of_result" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALof_result">¶</a><span id="VALof_result"><span class="keyword">val</span> of_result</span> : <code class="type">α <a href="Lwt.html#TYPEresult">Lwt.result</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.of_result&nbsp;r</code> converts an r to a resolved promise.
</p><ul>
<li>If <code>r</code> is <code>Ok&nbsp;v</code>, <code>Lwt.of_result&nbsp;r</code> is <code>Lwt.return&nbsp;v</code>, i.e. a promise
      fulfilled with <code>v</code>.</li>
<li>If <code>r</code> is <code>Error&nbsp;exn</code>, <code>Lwt.of_result&nbsp;r</code> is <code>Lwt.fail&nbsp;exn</code>, i.e. a promise
      rejected with <code>exn</code>.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.wakeup_later_result" data-ml-identifier="wakeup_later_result" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_later_result">¶</a><span id="VALwakeup_later_result"><span class="keyword">val</span> wakeup_later_result</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ α <a href="Lwt.html#TYPEresult">Lwt.result</a> ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_later_result&nbsp;r&nbsp;result</code> resolves the pending promise <code>p</code>
    associated to resolver <code>r</code>, according to <code>result</code>:
</p><ul>
<li>If <code>result</code> is <code>Ok&nbsp;v</code>, <code>p</code> is fulfilled with <code>v</code>.</li>
<li>If <code>result</code> is <code>Error&nbsp;exn</code>, <code>p</code> is rejected with <code>exn</code>.</li>
</ul><p>

    If <code>p</code> is not pending, <code>Lwt.wakeup_later_result</code> raises
    <code>Pervasives.Invalid_argument&nbsp;_</code>, except if <code>p</code> is <a href=" #VALcancel"> canceled</a>.
    If <code>p</code> is canceled, <code>Lwt.wakeup_later_result</code> has no effect.
</p></div>

</div><h3 id="3_Statequery"><a class="anchor" href="#3_Statequery">¶</a>State query</h3><div data-ml-fq-identifier="Lwt.state" data-ml-identifier="state" data-ml-kind="type" class="item"><pre><a class="anchor" href="#TYPEstate">¶</a><code><span id="TYPEstate"><span class="keyword">type</span> <code class="type">α</code> state</span> = </code>
  | <code><span id="TYPEELTstate.Return"><span class="constructor">Return</span></span> <span class="keyword">of</span> <code class="type">'a</code></code>
  | <code><span id="TYPEELTstate.Fail"><span class="constructor">Fail</span></span> <span class="keyword">of</span> <code class="type">exn</code></code>
  | <code><span id="TYPEELTstate.Sleep"><span class="constructor">Sleep</span></span></code></pre>



</div><div data-ml-fq-identifier="Lwt.state" data-ml-identifier="state" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALstate">¶</a><span id="VALstate"><span class="keyword">val</span> state</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEstate">Lwt.state</a></code></pre><div class="info "><p>
<code>Lwt.state&nbsp;p</code> evaluates to the current state of promise <code>p</code>:
</p><ul>
<li>If <code>p</code> is <a href=" #TYPEt"> fulfilled</a> with value <code>v</code>, the result is
      <code>Lwt.Return&nbsp;v</code>.</li>
<li>If <code>p</code> is <a href=" #TYPEt"> rejected</a> with exception <code>exn</code>, the result is
      <code>Lwt.Fail&nbsp;exn</code>.</li>
<li>If <code>p</code> is <a href=" #TYPEt"> pending</a>, the result is <code>Lwt.Sleep</code>.</li>
</ul><p>

    The constructor names are historical holdovers.
</p></div>

</div><h2 id="2_Deprecated"><a class="anchor" href="#2_Deprecated">¶</a>Deprecated</h2><h3 id="3_Implicitcallbackarguments"><a class="anchor" href="#3_Implicitcallbackarguments">¶</a>Implicit callback arguments</h3><div data-ml-fq-identifier="Lwt.key" data-ml-identifier="key" data-ml-kind="type" class="item"><pre><a class="anchor" href="#TYPEkey">¶</a><span id="TYPEkey"><span class="keyword">type</span> <code class="type">α</code> key</span> </pre>
<div class="info "><p>
Keys into the implicit callback argument map, for implicit arguments of type
    <code>α&nbsp;option</code>.
</p><p>

    The keys are abstract, but they are basically integers that are all distinct
    from each other.
</p><p>

    See <a href="Lwt.html#VALwith_value"><code>Lwt.with_value</code></a>.
</p></div>


</div><div data-ml-fq-identifier="Lwt.new_key" data-ml-identifier="new_key" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALnew_key">¶</a><span id="VALnew_key"><span class="keyword">val</span> new_key</span> : <code class="type">unit ⟶ α <a href="Lwt.html#TYPEkey">Lwt.key</a></code></pre><div class="info "><p>
Creates a fresh implicit callback argument key.
</p><p>

    The key is distinct from any other key created by the current process. The
    value <code>None</code> of type <code>α&nbsp;option</code> is immediately associated with the key.
</p><p>

    See <a href="Lwt.html#VALwith_value"><code>Lwt.with_value</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.get" data-ml-identifier="get" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALget">¶</a><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type">α <a href="Lwt.html#TYPEkey">Lwt.key</a> ⟶ α option</code></pre><div class="info "><p>
Retrieves the value currently associated with the given implicit callback
    argument key.
</p><p>

    See <a href="Lwt.html#VALwith_value"><code>Lwt.with_value</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.with_value" data-ml-identifier="with_value" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwith_value">¶</a><span id="VALwith_value"><span class="keyword">val</span> with_value</span> : <code class="type">α <a href="Lwt.html#TYPEkey">Lwt.key</a> ⟶ α option ⟶ (unit ⟶ β) ⟶ β</code></pre><div class="info "><p>
<code>Lwt.with_value&nbsp;k&nbsp;v&nbsp;f</code> sets <code>k</code> to <code>v</code> in Lwt's internal implicit callback
    argument map, then runs <code>f&nbsp;()</code>, then restores the previous value associated
    with <code>k</code>.
</p><p>

    Lwt maintains a single, global map, that can be used to “pass” extra
    arguments to callbacks:
</p><pre><code><span class="keyword">let</span> () =
  <span class="keyword">let</span> k : string <span class="constructor">Lwt</span>.key = <span class="constructor">Lwt</span>.new_key () <span class="keyword">in</span>

  <span class="keyword">let</span> say_hello () =
    <span class="keyword">match</span> <span class="constructor">Lwt</span>.get k <span class="keyword">with</span>
    <span class="keywordsign">|</span> <span class="constructor">None</span> <span class="keywordsign">-&gt;</span> <span class="keyword">assert</span> <span class="keyword">false</span>
    <span class="keywordsign">|</span> <span class="constructor">Some</span> s <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_io</span>.printl s
  <span class="keyword">in</span>

  <span class="constructor">Lwt_main</span>.run <span class="keyword">begin</span>
    <span class="constructor">Lwt</span>.with_value k (<span class="constructor">Some</span> <span class="string">"Hello world!"</span>) <span class="keyword">begin</span> <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
      <span class="constructor">Lwt</span>.bind
        (<span class="constructor">Lwt_unix</span>.sleep 1.)
        (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> say_hello ())
    <span class="keyword">end</span>
  <span class="keyword">end</span>

<span class="comment">(* ocamlfind opt -linkpkg -package lwt.ppx,lwt.unix code.ml &amp;&amp; ./a.out *)</span>
</code></pre><p>

    Note that the string <code>Hello&nbsp;world!</code> was passed to <code>say_hello</code> through the
    key <code>k</code>. Meanwhile, the only <em>explicit</em> argument of the callback
    <code>say_hello</code> is <code>()</code>.
</p><p>

    The way this works is functions like <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> take a <b>snapshot</b> of the
    implicit argument map. Later, right before the callback is run, the map is
    <em>restored</em> to that snapshot. In other words, the map has the same state
    inside the callback as it did at the time the callback was registered.
</p><p>

    To be more precise:
</p><ul>
<li><code>Lwt.with_value</code> associates <code>Some&nbsp;"Hello&nbsp;world!"</code> with <code>k</code>, and runs the
      function passed to it.</li>
<li>This function contains the <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>.</li>
<li>OCaml's eager evaluation means the arguments are evaluated first. In
      particular, the <code>Lwt_unix.sleep&nbsp;1.</code> promise is created.</li>
<li><a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> then attaches the callback in its second argument, the one
      which calls <code>say_hello</code>, to that <code>sleep</code> promise.</li>
<li><a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> also takes a snapshot of the current state of the implicit
      argument map, and pairs the callback with that snapshot.</li>
<li>The callback will not run for another second or so, when the <code>sleep</code>
      promise will be resolved.</li>
<li>Instead, <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> returns its result promise <code>p_3</code>. This causes
      <code>Lwt.with_value</code> to also return <code>p_3</code>, first restoring <code>k</code> to be
      associated with <code>None</code>.</li>
<li><a href="Lwt_main.html#VALrun"><code>Lwt_main.run</code></a> gets the pending <code>p_3</code>, and blocks the whole process, with
      <code>k</code> associated with <code>None</code>.</li>
<li>One second later, the <code>sleep</code> <span class="acronym">I/O</span> completes, resolving the <code>sleep</code>
      promise.</li>
<li>This triggers the <code>say_hello</code> callback. Right before the callback is
      called, the implicit argument map is restored to its snapshot, so <code>k</code> is
      associated with <code>Some&nbsp;"Hello&nbsp;world!"</code>.</li>
<li>After the callback completes, Lwt again restores <code>k</code> to be associated with
      <code>None</code>.</li>
</ul><p>

    The Lwt functions that take snapshots of the implicit callback argument map
    are exactly those which attach callbacks to promises: <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a> and its
    variants <code>&gt;&gt;=</code> and <code>let%lwt</code>, <a href="Lwt.html#VALmap"><code>Lwt.map</code></a> and its variant <code>&gt;|=</code>, <a href="Lwt.html#VALcatch"><code>Lwt.catch</code></a>
    and its variant <code>try%lwt</code>, <a href="Lwt.html#VALfinalize"><code>Lwt.finalize</code></a> and its variant <code>%lwt.finally</code>,
    <a href="Lwt.html#VALtry_bind"><code>Lwt.try_bind</code></a>, <a href="Lwt.html#VALon_success"><code>Lwt.on_success</code></a>, <a href="Lwt.html#VALon_failure"><code>Lwt.on_failure</code></a>,
    <a href="Lwt.html#VALon_termination"><code>Lwt.on_termination</code></a>, and <a href="Lwt.html#VALon_any"><code>Lwt.on_any</code></a>.
</p><p>

    Using this mechanism is discouraged, because it is non-syntactic, and
    because it manipulates hidden state in module <code>Lwt</code>. It is recommended
    instead to pass additional values explicitly in tuples, or maintain explicit
    associative maps for them.
</p></div>

</div><h3 id="3_Immediateresolving"><a class="anchor" href="#3_Immediateresolving">¶</a>Immediate resolving</h3><div data-ml-fq-identifier="Lwt.wakeup" data-ml-identifier="wakeup" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup">¶</a><span id="VALwakeup"><span class="keyword">val</span> wakeup</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ α ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup&nbsp;r&nbsp;v</code> is like <a href="Lwt.html#VALwakeup_later"><code>Lwt.wakeup_later</code></a><code>&nbsp;r&nbsp;v</code>, except it guarantees
    that callbacks associated with <code>r</code> will be called immediately, deeper on the
    current stack.
</p><p>

    In contrast, <a href="Lwt.html#VALwakeup_later"><code>Lwt.wakeup_later</code></a> <em>may</em> call callbacks immediately, or may
    queue them for execution on a shallower stack – though still before the next
    time Lwt blocks the process on <span class="acronym">I/O</span>.
</p><p>

    Using this function is discouraged, because calling it in a loop can exhaust
    the stack. The loop might be difficult to detect or predict, due to combined
    mutually-recursive calls between multiple modules and libraries.
</p><p>

    Also, trying to use this function to guarantee the timing of callback calls
    for synchronization purposes is discouraged. This synchronization effect is
    obscure to readers. It is better to use explicit promises, or <a href="Lwt_mutex.html"><code>Lwt_mutex</code></a>,
    <a href="Lwt_condition.html"><code>Lwt_condition</code></a>, and/or <a href="Lwt_mvar.html"><code>Lwt_mvar</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wakeup_exn" data-ml-identifier="wakeup_exn" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_exn">¶</a><span id="VALwakeup_exn"><span class="keyword">val</span> wakeup_exn</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ exn ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_exn&nbsp;r&nbsp;exn</code> is like <a href="Lwt.html#VALwakeup_later_exn"><code>Lwt.wakeup_later_exn</code></a><code>&nbsp;r&nbsp;exn</code>, but has
    the same problems as <a href="Lwt.html#VALwakeup"><code>Lwt.wakeup</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wakeup_result" data-ml-identifier="wakeup_result" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_result">¶</a><span id="VALwakeup_result"><span class="keyword">val</span> wakeup_result</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ α <a href="Lwt.html#TYPEresult">Lwt.result</a> ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_result&nbsp;r&nbsp;result</code> is like <a href="Lwt.html#VALwakeup_later_result"><code>Lwt.wakeup_later_result</code></a><code>&nbsp;r&nbsp;result</code>,
    but has the same problems as <a href="Lwt.html#VALwakeup"><code>Lwt.wakeup</code></a>.
</p></div>

</div><h3 id="3_Helpersforresolving"><a class="anchor" href="#3_Helpersforresolving">¶</a>Helpers for resolving</h3><div data-ml-fq-identifier="Lwt.make_value" data-ml-identifier="make_value" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALmake_value">¶</a><span id="VALmake_value"><span class="keyword">val</span> make_value</span> : <code class="type">α ⟶ α <a href="Lwt.html#TYPEresult">Lwt.result</a></code></pre><div class="info "><p>
<code>Lwt.make_value&nbsp;v</code> is equivalent to
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult">
    <code>Ok&nbsp;v</code></a> since OCaml 4.03. If you need compatibility with OCaml 4.02, use
    <code>Result.Ok</code> and depend on opam package
    <a href=" https://opam.ocaml.org/packages/result/"> <code>result</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.make_error" data-ml-identifier="make_error" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALmake_error">¶</a><span id="VALmake_error"><span class="keyword">val</span> make_error</span> : <code class="type">exn ⟶ α <a href="Lwt.html#TYPEresult">Lwt.result</a></code></pre><div class="info "><p>
<code>Lwt.make_error&nbsp;exn</code> is equivalent to
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult">
    <code>Error&nbsp;exn</code></a> since OCaml 4.03. If you need compatibility with OCaml 4.02,
    use <code>Result.Error</code> and depend on opam package
    <a href=" https://opam.ocaml.org/packages/result/"> <code>result</code></a>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.waiter_of_wakener" data-ml-identifier="waiter_of_wakener" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwaiter_of_wakener">¶</a><span id="VALwaiter_of_wakener"><span class="keyword">val</span> waiter_of_wakener</span> : <code class="type">α <a href="Lwt.html#TYPEu">Lwt.u</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.waiter_of_wakener&nbsp;r</code> evaluates to the promise associated with resolver
    <code>r</code>.
</p><p>

    It is recommended to explicitly keep the reference to the promise
    instead.
</p></div>

</div><h3 id="3_Linkedlistsofpromises"><a class="anchor" href="#3_Linkedlistsofpromises">¶</a>Linked lists of promises</h3><div data-ml-fq-identifier="Lwt.add_task_r" data-ml-identifier="add_task_r" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALadd_task_r">¶</a><span id="VALadd_task_r"><span class="keyword">val</span> add_task_r</span> : <code class="type">(α <a href="Lwt.html#TYPEu">Lwt.u</a>) <a href="Lwt_sequence.html#TYPEt">Lwt_sequence.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.add_task_r&nbsp;sequence</code> is equivalent to
</p><pre><code><span class="keyword">let</span> p, r = <span class="constructor">Lwt</span>.task () <span class="keyword">in</span>
<span class="keyword">let</span> node = <span class="constructor">Lwt_sequence</span>.add_r r sequence <span class="keyword">in</span>
<span class="constructor">Lwt</span>.on_cancel p (<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">Lwt_sequence</span>.remove node);
p
</code></pre><p>

    Use of this function is discouraged for two reasons:
</p><ul>
<li><a href="Lwt_sequence.html"><code>Lwt_sequence</code></a> should not be used outside Lwt.</li>
<li>This function only exists because it performs a minor internal
      optimization, which may be removed.</li>
</ul></div>

</div><div data-ml-fq-identifier="Lwt.add_task_l" data-ml-identifier="add_task_l" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALadd_task_l">¶</a><span id="VALadd_task_l"><span class="keyword">val</span> add_task_l</span> : <code class="type">(α <a href="Lwt.html#TYPEu">Lwt.u</a>) <a href="Lwt_sequence.html#TYPEt">Lwt_sequence.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
Like <a href="Lwt.html#VALadd_task_r"><code>Lwt.add_task_r</code></a>, but the equivalent code calls <a href="Lwt_sequence.html#VALadd_l"><code>Lwt_sequence.add_l</code></a>
    instead.
</p></div>

</div><h3 id="3_Pausing"><a class="anchor" href="#3_Pausing">¶</a>Pausing</h3><div data-ml-fq-identifier="Lwt.pause" data-ml-identifier="pause" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALpause">¶</a><span id="VALpause"><span class="keyword">val</span> pause</span> : <code class="type">unit ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.pause&nbsp;()</code> creates a pending promise that is fulfilled the next time
    <a href="Lwt.html#VALwakeup_paused"><code>Lwt.wakeup_paused</code></a> is called.
</p><p>

    This function is intended for internal use by Lwt.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wakeup_paused" data-ml-identifier="wakeup_paused" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwakeup_paused">¶</a><span id="VALwakeup_paused"><span class="keyword">val</span> wakeup_paused</span> : <code class="type">unit ⟶ unit</code></pre><div class="info "><p>
<code>Lwt.wakeup_paused&nbsp;()</code> fulfills all promises created with <a href="Lwt.html#VALpause"><code>Lwt.pause</code></a> since
    the last time <code>Lwt.wakeup_paused</code> was called, or since the process was
    started.
</p><p>

    This function is intended for internal use by Lwt.
</p></div>

</div><div data-ml-fq-identifier="Lwt.paused_count" data-ml-identifier="paused_count" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALpaused_count">¶</a><span id="VALpaused_count"><span class="keyword">val</span> paused_count</span> : <code class="type">unit ⟶ int</code></pre><div class="info "><p>
Returns the number of promises that would be fulfilled by calling
    <a href="Lwt.html#VALwakeup_paused"><code>Lwt.wakeup_paused</code></a> right now.
</p><p>

    This function is intended for internal use by Lwt.
</p></div>

</div><div data-ml-fq-identifier="Lwt.register_pause_notifier" data-ml-identifier="register_pause_notifier" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALregister_pause_notifier">¶</a><span id="VALregister_pause_notifier"><span class="keyword">val</span> register_pause_notifier</span> : <code class="type">(int ⟶ unit) ⟶ unit</code></pre><div class="info "><p>
 causes <code>f</code> to be called every time
    <a href="Lwt.html#VALpause"><code>Lwt.pause</code></a> is called. The result of <a href="Lwt.html#VALpaused_count"><code>Lwt.paused_count</code></a><code>&nbsp;()</code> is passed to
    <code>f</code>.
</p><p>

    Only one such function can be registered at a time. There is only a single
    internal reference cell available for this purpose.
</p><p>

    This function is intended for internal use by Lwt.
</p></div>

</div><h3 id="3_Functionlifters"><a class="anchor" href="#3_Functionlifters">¶</a>Function lifters</h3><div data-ml-fq-identifier="Lwt.wrap" data-ml-identifier="wrap" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap">¶</a><span id="VALwrap"><span class="keyword">val</span> wrap</span> : <code class="type">(unit ⟶ α) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.wrap&nbsp;f</code> applies <code>f&nbsp;()</code>. If <code>f&nbsp;()</code> returns a value <code>v</code>, <code>Lwt.wrap</code>
    returns <a href="Lwt.html#VALreturn"><code>Lwt.return</code></a><code>&nbsp;v</code>. If <code>f&nbsp;()</code> raises an exception exn, <code>Lwt.wrap</code>
    returns <a href="Lwt.html#VALfail"><code>Lwt.fail</code></a><code>&nbsp;exn</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.wrap1" data-ml-identifier="wrap1" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap1">¶</a><span id="VALwrap1"><span class="keyword">val</span> wrap1</span> : <code class="type">
  (α ⟶ β) ⟶
    (α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap2" data-ml-identifier="wrap2" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap2">¶</a><span id="VALwrap2"><span class="keyword">val</span> wrap2</span> : <code class="type">
  (α ⟶ β ⟶ γ) ⟶
    (α ⟶ β ⟶ γ <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap3" data-ml-identifier="wrap3" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap3">¶</a><span id="VALwrap3"><span class="keyword">val</span> wrap3</span> : <code class="type">
  (α ⟶ β ⟶ γ ⟶ δ) ⟶
    (α ⟶ β ⟶ γ ⟶ δ <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap4" data-ml-identifier="wrap4" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap4">¶</a><span id="VALwrap4"><span class="keyword">val</span> wrap4</span> : <code class="type">
  (α ⟶ β ⟶ γ ⟶ δ ⟶ ε) ⟶
    (α ⟶ β ⟶ γ ⟶ δ ⟶ ε <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap5" data-ml-identifier="wrap5" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap5">¶</a><span id="VALwrap5"><span class="keyword">val</span> wrap5</span> : <code class="type">
  (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ) ⟶
    (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap6" data-ml-identifier="wrap6" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap6">¶</a><span id="VALwrap6"><span class="keyword">val</span> wrap6</span> : <code class="type">
  (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ ⟶ η) ⟶
    (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ ⟶ η <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre>
</div><div data-ml-fq-identifier="Lwt.wrap7" data-ml-identifier="wrap7" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALwrap7">¶</a><span id="VALwrap7"><span class="keyword">val</span> wrap7</span> : <code class="type">
  (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ ⟶ η ⟶ θ) ⟶
    (α ⟶ β ⟶ γ ⟶ δ ⟶ ε ⟶ ζ ⟶ η ⟶ θ <a href="Lwt.html#TYPEt">Lwt.t</a>)</code></pre><div class="info "><p>
As a “prototype,” <code>Lwt_wrap1&nbsp;f</code> creates a promise-valued function <code>g</code>:
</p><pre><code><span class="keyword">let</span> g v =
  <span class="keyword">try</span>
    <span class="keyword">let</span> v' = f v <span class="keyword">in</span>
    <span class="constructor">Lwt</span>.return v'
  <span class="keyword">with</span> exn <span class="keywordsign">-&gt;</span>
    <span class="constructor">Lwt</span>.fail exn
</code></pre><p>

    The remainder of the functions work analogously – they just work on <code>f</code> with
    larger numbers of arguments.
</p><p>

    Note that there is an important difference to <a href="Lwt.html#VALwrap"><code>Lwt.wrap</code></a>. These functions
    don't run <code>f</code>, nor create the final promise, immediately. In contrast,
    <a href="Lwt.html#VALwrap"><code>Lwt.wrap</code></a> runs its argument <code>f</code> eagerly.
</p><p>

    To get a suspended function instead of the eager execution of <a href="Lwt.html#VALwrap"><code>Lwt.wrap</code></a>,
    use <code>Lwt.wrap1</code>.
</p></div>

</div><h3 id="3_Trivialpromises"><a class="anchor" href="#3_Trivialpromises">¶</a>Trivial promises</h3><div data-ml-fq-identifier="Lwt.return_some" data-ml-identifier="return_some" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_some">¶</a><span id="VALreturn_some"><span class="keyword">val</span> return_some</span> : <code class="type">α ⟶ (α option) <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
Counterpart to <a href="Lwt.html#VALreturn_none"><code>Lwt.return_none</code></a>. However, unlike <a href="Lwt.html#VALreturn_none"><code>Lwt.return_none</code></a>, this
    function performs no <a href=" #VALreturn_unit"> optimization</a>. This is because it
    takes an argument, so it cannot be evaluated at initialization time, at
    which time the argument is not yet available.
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_ok" data-ml-identifier="return_ok" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_ok">¶</a><span id="VALreturn_ok"><span class="keyword">val</span> return_ok</span> : <code class="type">α ⟶ [(α, β) Result.result] <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
Like <a href="Lwt.html#VALreturn_some"><code>Lwt.return_some</code></a>, this function performs no optimization.
</p><p><b>Since</b> Lwt 2.6.0
</p></div>

</div><div data-ml-fq-identifier="Lwt.return_error" data-ml-identifier="return_error" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALreturn_error">¶</a><span id="VALreturn_error"><span class="keyword">val</span> return_error</span> : <code class="type">α ⟶ [(α, β) Result.result] <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
Like <a href="Lwt.html#VALreturn_some"><code>Lwt.return_some</code></a>, this function performs no optimization.
</p><p><b>Since</b> Lwt 2.6.0
</p></div>

</div><div data-ml-fq-identifier="Lwt.fail_with" data-ml-identifier="fail_with" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALfail_with">¶</a><span id="VALfail_with"><span class="keyword">val</span> fail_with</span> : <code class="type">string ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.fail_with&nbsp;s</code> is an abbreviation for
</p><pre><code><span class="constructor">Lwt</span>.fail (<span class="constructor">Pervasives</span>.<span class="constructor">Failure</span> s)
</code></pre></div>

</div><div data-ml-fq-identifier="Lwt.fail_invalid_arg" data-ml-identifier="fail_invalid_arg" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALfail_invalid_arg">¶</a><span id="VALfail_invalid_arg"><span class="keyword">val</span> fail_invalid_arg</span> : <code class="type">string ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
<code>Lwt.invalid_arg&nbsp;s</code> is an abbreviation for
</p><pre><code><span class="constructor">Lwt</span>.fail (<span class="constructor">Pervasives</span>.<span class="constructor">Invalid_argument</span> s)
</code></pre></div>

</div><h3 id="3_Unscopedinfixoperators"><a class="anchor" href="#3_Unscopedinfixoperators">¶</a>Unscoped infix operators</h3><div data-ml-fq-identifier="Lwt.(>>=)" data-ml-identifier="(>>=)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(>>=)">¶</a><span id="VAL(>>=)"><span class="keyword">val</span> (&gt;&gt;=)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
</div><div data-ml-fq-identifier="Lwt.(>|=)" data-ml-identifier="(>|=)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(>|=)">¶</a><span id="VAL(>|=)"><span class="keyword">val</span> (&gt;|=)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ (α ⟶ β) ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
</div><div data-ml-fq-identifier="Lwt.(<?>)" data-ml-identifier="(<?>)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(<?>)">¶</a><span id="VAL(<?>)"><span class="keyword">val</span> (&lt;?&gt;)</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
</div><div data-ml-fq-identifier="Lwt.(<&amp;>)" data-ml-identifier="(<&amp;>)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(<&amp;>)">¶</a><span id="VAL(<&amp;>)"><span class="keyword">val</span> (&lt;&amp;&gt;)</span> : <code class="type">unit <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
</div><div data-ml-fq-identifier="Lwt.(=<<)" data-ml-identifier="(=<<)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(=<<)">¶</a><span id="VAL(=<<)"><span class="keyword">val</span> (=&lt;&lt;)</span> : <code class="type">(α ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a>) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre>
</div><div data-ml-fq-identifier="Lwt.(=|<)" data-ml-identifier="(=|<)" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VAL(=|<)">¶</a><span id="VAL(=|<)"><span class="keyword">val</span> (=|&lt;)</span> : <code class="type">(α ⟶ β) ⟶ α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ β <a href="Lwt.html#TYPEt">Lwt.t</a></code></pre><div class="info "><p>
Use the operators in module <a href=" #MODULEInfix"> <code>Lwt.Infix</code></a> instead. Using
    these instances of the operators directly requires opening module <code>Lwt</code>,
    which brings an excessive number of other names into scope.
</p></div>

</div><h3 id="3_Miscellaneous"><a class="anchor" href="#3_Miscellaneous">¶</a>Miscellaneous</h3><div data-ml-fq-identifier="Lwt.is_sleeping" data-ml-identifier="is_sleeping" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALis_sleeping">¶</a><span id="VALis_sleeping"><span class="keyword">val</span> is_sleeping</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ bool</code></pre><div class="info "><p>
<code>Lwt.is_sleeping&nbsp;p</code> is equivalent to <a href="Lwt.html#VALstate"><code>Lwt.state</code></a><code>&nbsp;p&nbsp;=&nbsp;Lwt.Sleep</code>.
</p></div>

</div><div data-ml-fq-identifier="Lwt.ignore_result" data-ml-identifier="ignore_result" data-ml-kind="val" class="item"><pre><a class="anchor" href="#VALignore_result">¶</a><span id="VALignore_result"><span class="keyword">val</span> ignore_result</span> : <code class="type">α <a href="Lwt.html#TYPEt">Lwt.t</a> ⟶ unit</code></pre><div class="info "><p>
An obsolete variant of <a href="Lwt.html#VALasync"><code>Lwt.async</code></a>.
</p><p>

    <code>Lwt.ignore_result&nbsp;p</code> behaves as follows:
</p><ul>
<li>If <code>p</code> is already fulfilled, <code>Lwt.ignore_result&nbsp;p</code> does nothing.</li>
<li>If <code>p</code> is already rejected with <code>exn</code>, <code>Lwt.ignore_result&nbsp;p</code> raises <code>exn</code>
      immedaitely.</li>
<li>If <code>p</code> is pending, <code>Lwt.ignore_result&nbsp;p</code> does nothing, but if <code>p</code> becomes
      rejected later, the exception is passed to <a href="Lwt.html#VALasync_exception_hook"><code>!Lwt.async_exception_hook</code></a>.</li>
</ul><p>

    Use of this function is discouraged for two reasons:
</p><ul>
<li>The behavior is different depending on whether <code>p</code> is rejected now or
      later.</li>
<li>The name is misleading, and has led to users thinking this function is
      analogous to <code>Pervasives.ignore</code>, i.e. that it waits for <code>p</code> to become
      resolved, completing any associated side effects along the way. In fact,
      the function that does <em>that</em> is ordinary <a href="Lwt.html#VALbind"><code>Lwt.bind</code></a>.</li>
</ul></div>
</div></div></div></body></html>