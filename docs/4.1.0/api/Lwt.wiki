=Module <<a_api_type | module Lwt >> =
<<pre class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|module>> <<span class="ocsforge_color_uid"|<<span class="ocsforge_color_uid"|Lwt>>>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="ocsforge_color_keyword"|sig>><<a_api text=".." | module Lwt >><<span class="ocsforge_color_keyword"|end>>>>~Asynchronous programming with promises~.


    ~A **promise** is a placeholder for a single value which might take a long
    time to compute~. ~Speaking roughly~, a promise is a <<span class="odocwiki_inlinecode"|ref>> that can be filled
    in later~. ~To make that precise~, here is how promises differ from <<span class="odocwiki_inlinecode"|ref>>s~:


* ~A promise might not have a value yet~. ~A promise in this state is called a
      //pending// promise~.
* ~Writing a value into a promise is called //resolving// it~. ~A promise with
      a value is called a //resolved// promise~.
* ~Each promise can be resolved only once~. ~After a promise has a value~, the
      promise is immutable~.
* ~It~'s possible to attach **callbacks** to a promise~. ~They will run when the
      promise has a value~, i~.e~. is resolved~. ~If the promise is already resolved
      when a callback is attached~, the callback is run ~(almost~) right away~. ~If
      the promise is pending~, the callback is put into a list and waits~.

    ~So~, promises are optional~, write~-once references~, and when they don~'t yet
    have a value~, they store a list of callbacks that are waiting for the value~.


    ~The waiting callbacks make promises a natural data type for asynchronous
    programming~. ~For example~, you can ask ~Lwt to <<span class="odocwiki_inlinecode"|read>> a file~. ~Lwt immediately
    returns you only a //promise// for the data~.


    ~You can neglect this promise for a while~. ~You can do some other computation~,
    request more ~I~/~O~, etc~. ~At some point~, you might decide to attach a callback
    to the <<span class="odocwiki_inlinecode"|read>> promise~, maybe several callbacks~.


    ~In the meantime~, the <<span class="odocwiki_inlinecode"|read>> operation is running in the background~. ~Once it
    finishes~, ~Lwt //resolves// the <<span class="odocwiki_inlinecode"|read>> promise by putting the data into it~.
    ~Lwt then runs the callbacks you attached~.


    ~One of those might take the data~, and ask ~Lwt to <<span class="odocwiki_inlinecode"|write>> it to ~S~T~D~O~U~T~. ~Lwt
    gives you a promise for that~, too~, and the process repeats~.


    ~Lwt has a small amount of syntactic sugar to make this look as natural as
    possible~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let%lwt data = Lwt_io.(read_line stdin) in
    let%lwt () = Lwt_io.printl data in
    Lwt.return ()
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix echo.ml && ./a.out *)
>>



    ~This is all explained in the next sections~:


* [[ #3_Quickstart| ~Quick start]] links these concepts to actual functions
      in ~Lwt – the most fundamental ones~.
* [[ #3_Tutorial| ~Tutorial]] shows how to write examples like the above~, and
      how concurrency happens~.
* [[ #3_Executionmodel| ~Execution model]] clarifies control flow when using
      ~Lwt~.
* [[ #3_GuidetotherestofLwt| ~Guide to the rest of ~Lwt]] shows how
      //everything// else in ~Lwt fits into this framework~.

    ~After that is the [[ #2_Fundamentals| reference proper]]~, which goes into
    //painful// levels of detail on every single type and value in this module~,
    <<span class="odocwiki_inlinecode"|~Lwt>>~. ~Please be safe~, and read only what you need from it ~:~)


    ~Happy asynchronous programming!


    
===@@id="3_Quickstart"@@~Quick start===



    //~All// of ~Lwt is variations on~:


* **~Promises** of type <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.t >> are placeholders for values of type
      <<span class="odocwiki_inlinecode"|~'a>>~.
* <<a_api | val Lwt.bind >> attaches **callbacks** to promises~. ~When a promise gets a
      value~, its callbacks are called~.
* ~Separate **resolvers** of type <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.u >> are used to write values into
      promises~, through <<a_api | val Lwt.wakeup_later >>~.
* ~Promises and resolvers are created in pairs using <<a_api | val Lwt.task >>~. ~Lwt ~I~/~O
      functions call <<a_api | val Lwt.task >> internally~, but return only the promise~.
* <<a_api | val Lwt_main.run >> is used to wait on one “top~-level” promise~. ~When that
      promise gets a value~, the program terminates~.

    
===@@id="3_Tutorial"@@~Tutorial===



    ~Let~'s read  from ~S~T~D~I~N~. ~The first version is written using ordinary values
    from the ~O~Caml standard library~. ~This makes the program block until the user
    enters a line~:



<<code language='ocaml'|let () =
  let line : string =
    Pervasives.read_line () in
  print_endline "Now unblocked!";
  ignore line

(* ocamlfind opt -linkpkg code.ml && ./a.out *)
>>



    ~If we use a promise instead~, execution continues immediately~:



<<code language='ocaml'|let () =
  let line_promise : string Lwt.t =
    Lwt_io.(read_line stdin) in
  print_endline "Execution just continues...";
  ignore line_promise

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~Indeed~, this program is a little //too// asynchronous – it exits right away!
    ~Let~'s force it to wait for <<span class="odocwiki_inlinecode"|line~_promise>> at the end by calling
    <<a_api | val Lwt_main.run >>~:



<<code language='ocaml'|let () =
  let line_promise : string Lwt.t =
    Lwt_io.(read_line stdin) in
  print_endline "Execution just continues...";

  let line : string =
    Lwt_main.run line_promise in
  ignore line

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    <<a_api | val Lwt_main.run >> should only be called once~, on one promise~, at the top level
    of your program~. ~Most of the time~, waiting for promises is done using
    <<span class="odocwiki_inlinecode"|let~%lwt>>~. ~That is the recommended syntactic sugar for <<a_api | val Lwt.bind >>~, and is
    pronounced “bind”~:



<<code language='ocaml'|let () =
  let p : unit Lwt.t =
    let%lwt line_1 = Lwt_io.(read_line stdin) in
    let%lwt line_2 = Lwt_io.(read_line stdin) in
    Lwt_io.printf "%s and %s\n" line_1 line_2
  in

  Lwt_main.run p

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~The way that works is everything in scope after the “<<span class="odocwiki_inlinecode"|in>>” in
    “<<span class="odocwiki_inlinecode"|let~%lwt x ~=>> ~.~.~. <<span class="odocwiki_inlinecode"|in>> ~.~.~.” goes into a callback~, and “<<span class="odocwiki_inlinecode"|x>>” is that
    callback~'s argument~. ~So~, we could have been very explicit~, and written the
    code like this~:



<<code language='ocaml'|let () =
  let p : unit Lwt.t =
    let line_1_promise : string Lwt.t = Lwt_io.(read_line stdin) in
    Lwt.bind line_1_promise (fun (line_1 : string) ->

      let line_2_promise : string Lwt.t = Lwt_io.(read_line stdin) in
      Lwt.bind line_2_promise (fun (line_2 : string) ->

        Lwt_io.printf "%s and %s\n" line_1 line_2))
  in

  Lwt_main.run p

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~But~, as you can see~, this is verbose~, and the indentation gets a bit crazy~.
    ~So~, we will always use <<span class="odocwiki_inlinecode"|let~%lwt>>~.


    ~The code above reads two lines in sequence~, because we ask ~Lwt to wait for
    <<span class="odocwiki_inlinecode"|line~_~1>>~, before calling the second <<a_api | val Lwt_io.read_line >> in the callback~, to
    start the second ~I~/~O~.


    ~We could also run ~I~/~O //concurrently//~. ~All we have to do is not start the
    second ~I~/~O in a callback of the first~. ~Because it doesn~'t make sense to read
    two lines from ~S~T~D~I~N concurrently~, let~'s start two waits instead~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let three_seconds : unit Lwt.t = Lwt_unix.sleep 3. in
    let five_seconds : unit Lwt.t = Lwt_unix.sleep 5. in
    let%lwt () = three_seconds in
    let%lwt () = Lwt_io.printl "3 seconds passed" in
    let%lwt () = five_seconds in
    Lwt_io.printl "Only 2 more seconds passed"
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~This program takes about five seconds to run~. ~We are still new to <<span class="odocwiki_inlinecode"|let~%lwt>>~,
    so let~'s desugar it~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let three_seconds : unit Lwt.t = Lwt_unix.sleep 3. in
    let five_seconds : unit Lwt.t = Lwt_unix.sleep 5. in

    (* Both waits have already been started at this point! *)

    Lwt.bind three_seconds (fun () ->
      (* This is 3 seconds later. *)
      Lwt.bind (Lwt_io.printl "3 seconds passed") (fun () ->
        Lwt.bind five_seconds (fun () ->
          (* Only 2 seconds were left in the 5-second wait, so
              this callback runs 2 seconds after the first callback. *)
          Lwt_io.printl "Only 2 more seconds passed")))
  end

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~And that~'s it! ~Concurrency in ~Lwt is simply a matter of whether you start an
    operation in the callback of another one or not~. ~As a convenience~, ~Lwt
    provides a few [[ #2_Concurrency| helpers]] for common concurrency patterns~.


    
===@@id="3_Executionmodel"@@~Execution model===



    ~It~'s important to understand that promises are a pure~-~O~Caml data type~. ~They
    don~'t do any fancy scheduling or ~I~/~O~. ~They are just lists of callbacks ~(if
    pending~)~, or containers for one value ~(if resolved~)~.


    ~The interesting function is <<a_api | val Lwt_main.run >>~. ~It~'s a wrapper around
    [[ http://man7.org/linux/man-pages/man2/select.2.html| <<span class="odocwiki_inlinecode"|select~(~2~)>>]]~,
    [[ http://man7.org/linux/man-pages/man7/epoll.7.html| <<span class="odocwiki_inlinecode"|epoll~(~7~)>>]]~,
    [[ https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2|
    <<span class="odocwiki_inlinecode"|kqueue~(~2~)>>]]~, or whatever asynchronous ~I~/~O ~A~P~I your system provides~. ~On
    browsers~, the work of <<a_api | val Lwt_main.run >> is done by the surrouding ~Java~Script
    engine~, so you don~'t call <<a_api | val Lwt_main.run >> from inside your program~. ~But the
    execution model is still the same~, and the description below applies!


    ~To avoid writing out “underlying asynchronous ~I~/~O ~A~P~I~,” we~'ll assume~, in
    this section~, that the ~A~P~I is <<span class="odocwiki_inlinecode"|select~(~2~)>>~. ~That~'s just for the sake of
    abbreviation~. ~It doesn~'t actually matter~, for most purposes~, what the
    underlying ~I~/~O ~A~P~I is~.


    ~Let~'s use the program from the tutorial that reads two lines as an example~.
    ~Here it is~, again~, in its desugared form~:



<<code language='ocaml'|let () =
  let p : unit Lwt.t =
    let line_1_promise : string Lwt.t = Lwt_io.(read_line stdin) in
    Lwt.bind line_1_promise (fun (line_1 : string) ->

      let line_2_promise : string Lwt.t = Lwt_io.(read_line stdin) in
      Lwt.bind line_2_promise (fun (line_2 : string) ->

        Lwt_io.printf "%s and %s\n" line_1 line_2))
  in

  Lwt_main.run p

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    <<a_api | val Lwt_main.run >> is your program~'s main ~I~/~O loop~. ~You pass it a single
    promise~, and it~:

# ~Uses <<span class="odocwiki_inlinecode"|select~(~2~)>> to put your process to sleep until the next ~I~/~O
      completes~.
# ~That next ~I~/~O happens to be the one that reads <<span class="odocwiki_inlinecode"|line~_~1>>~. <<a_api | val Lwt_main.run >>
      knows that ~I~/~O is supposed to resolve <<span class="odocwiki_inlinecode"|line~_~1~_promise>>~, so it puts
      <<span class="odocwiki_inlinecode"|line~_~1>> into the promise and resolves it~.
# ~Resolving is an ordinary ~O~Caml operation~. ~It causes all the callbacks of
      <<span class="odocwiki_inlinecode"|line~_~1~_promise>> to run~, one after another~. ~Each callback is also ordinary
      ~O~Caml code~. ~In our case~, there is only one callback~, but in general~, there
      might be several~, and they might also resolve additional promises~. ~So~,
      promise resolution triggers a “cascade” of callbacks~. ~Eventually~, however~,
      we should run out of callbacks~, and control will return to
      <<a_api | val Lwt_main.run >>~.
# ~In our example~, our one callback registers a second ~I~/~O with
      <<a_api | val Lwt_main.run >> – the one that will read <<span class="odocwiki_inlinecode"|line~_~2>>~. ~There are no callbacks
      left to run after that~, so control returns to <<a_api | val Lwt_main.run >>~.
# <<a_api | val Lwt_main.run >> goes back to sleep again by calling <<span class="odocwiki_inlinecode"|select~(~2~)>>~, now
      waiting for the second ~I~/~O that we just registered~. ~The loop repeats
      itself from step ~1~.


    ~This has two major implications~, one good and one bad~. ~Let~'s start with the
    bad one~.


    **~(~1~)** ~If one of your callbacks enters an infinite loop~, calls an
    ~Lwt~-unfriendly blocking ~I~/~O~, or just runs for a really long time~, it won~'t
    return control to <<a_api | val Lwt_main.run >> anytime soon~. ~That means <<a_api | val Lwt_main.run >>
    won~'t get a chance to resolve any other ~Lwt ~I~/~O promises~, even if the
    underlying ~I~/~O operations complete~.


    ~In case your callback is just using the ~C~P~U for a really long time~, you can
    insert a few calls to <<a_api | val Lwt_main.yield >> into it~, and resume your computation
    in callbacks of <<span class="odocwiki_inlinecode"|yield>>~. ~This is basically the same as
    <<a_api | val Lwt_unix.sleep >><<span class="odocwiki_inlinecode"| ~0~.>> – it~'s a promise that will be resolved by
    <<a_api | val Lwt_main.run >> //after// any other ~I~/~O resolutions that are already in its
    queue~.


    **~(~2~)** ~The good implication is that all your callbacks run in a single
    thread~. ~This means that in most situations~, you don~'t have to worry about
    locks~, synchronization~, etc~. ~Anything that is in the same callback is
    guaranteed to run without interruption~. ~Lwt programs are often //much//
    easier to write and refactor~, than equivalent programs written with threads
    – but both are concurrent!


    
===@@id="3_GuidetotherestofLwt"@@~Guide to the rest of ~Lwt===



    ~This module <<span class="odocwiki_inlinecode"|~Lwt>> is the pure~-~O~Caml definition of promises and
    callback~-calling~. ~It has a few extras on top of what~'s described above~:


* [[ #2_Rejection| ~Rejection]]~. ~Lwt promises can actually be resolved in two
      ways~: //fulfilled// with a value~, or //rejected// with an exception~. ~There
      is nothing conceptually special about rejection – it~'s just that you can
      ask for callbacks to run only on fulfillment~, only on rejection~, etc~.
* [[ #2_Cancelation| ~Cancelation]]~. ~This is a special case of rejection~,
      specifically with exception <<a_api | exception Lwt.Canceled >>~. ~It has extra helpers in the
      ~Lwt ~A~P~I~.
* [[ #2_Concurrency| ~Concurrency helpers]]~. ~All of these could be
      implemented on top of <<a_api | val Lwt.bind >>~. ~As we saw~, ~Lwt concurrency requires
      only deciding whether to run something inside a callback~, or outside it~.
      ~These functions just implement common patterns~, and make intent explicit~.
* ~Miscellaneous [[ #2_Convenience| helpers]]~, and [[ #2_Deprecated|
      deprecated]] ~A~P~Is~.

    ~The next layer above module <<span class="odocwiki_inlinecode"|~Lwt>> is the pure~-~O~Caml ~Lwt “core” library~,
    which provides some promise~-friendly patterns~, like streams and mvars~. ~This
    consists of the modules <<a_api | module Lwt_list >>~, <<a_api | module Lwt_stream >>~, <<a_api | module Lwt_result >>~,
    <<a_api | module Lwt_mutex >>~, <<a_api | module Lwt_condition >>~, <<a_api | module Lwt_mvar >>~, <<a_api | module Lwt_pool >>~, and <<a_api | module Lwt_switch >>~.


    ~Above that is the ~Lwt ~Unix binding~, where ~I~/~O begins~. ~This includes the
    module <<a_api | module Lwt_main >>~, including the all~-important <<a_api | val Lwt_main.run >>~. ~The rest of
    the ~Unix binding consists of functions~, each one of which~.~.~.


* ~.~.~.starts a background ~I~/~O operation~,
* creates a promise for it and gives it to you~,
* registers with <<a_api | val Lwt_main.run >>~, so if you attach callbacks to the promise~,
      they will be called when the ~I~/~O operation completes~.

    ~The functions are grouped into modules~:


* <<a_api | module Lwt_unix >> for ~Unix system calls~.
* <<a_api | module Lwt_bytes >> for ~Unix system calls on bigarrays~.
* <<a_api | module Lwt_io >> for <<span class="odocwiki_inlinecode"|~Pervasives>>~-like high~-level channels~, ~T~C~P servers~, etc~.
* <<a_api | module Lwt_process >> for managing subprocesses~.
* <<a_api | module Lwt_preemptive >> for spawning system threads~.
* ~Miscellaneous modules <<a_api | module Lwt_gc >>~, <<a_api | module Lwt_engine >>~, <<a_api | module Lwt_throttle >>~,
      <<a_api | module Lwt_timeout >>~, <<a_api | module Lwt_sys >>~.

    ~Warning! ~Introductory material ends and detailed reference begins!

----


==@@id="2_Fundamentals"@@~Fundamentals==



===@@id="3_Promises"@@~Promises===

<<pre class="ocsforge_color odocwiki_code" id="TYPEt"|<<span class="ocsforge_color_keyword"|type>> <<span class="odocwiki_type"|+'a>> <<span class="odocwiki_name"|t>>>><<div class="odocwiki_info"|~Promises for values of type <<span class="odocwiki_inlinecode"|~'a>>~.


    ~A **promise** is a memory cell that is always in one of three **states**~:


* //fulfilled//~, and containing one value of type <<span class="odocwiki_inlinecode"|~'a>>~,
* //rejected//~, and containing one exception~, or
* //pending//~, in which case it may become fulfilled or rejected later~.

    ~A //resolved// promise is one that is either fulfilled or rejected~, i~.e~. not
    pending~. ~Once a promise is resolved~, its content cannot change~. ~So~, promises
    are //write~-once references//~. ~The only possible state changes are ~(~1~) from
    pending to fulfilled and ~(~2~) from pending to rejected~.


    ~Promises are typically “read” by attaching **callbacks** to them~. ~The most
    basic functions for that are <<a_api | val Lwt.bind >>~, which attaches a callback that is
    called when a promise becomes fulfilled~, and <<a_api | val Lwt.catch >>~, for rejection~.


    ~Promise variables of this type~, <<span class="odocwiki_inlinecode"|~'a ~Lwt~.t>>~, are actually **read~-only** in
    ~Lwt~. ~Separate //resolvers// of type <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.u >> are used to write to them~.
    ~Promises and their resolvers are created together by calling <<a_api | val Lwt.task >>~.
    ~There is one exception to this~: most promises can be //canceled// by calling
    <<a_api | val Lwt.cancel >>~, without going through a resolver~.
>>
<<pre class="ocsforge_color odocwiki_code" id="TYPEu"|<<span class="ocsforge_color_keyword"|type>> <<span class="odocwiki_type"|-'a>> <<span class="odocwiki_name"|u>>>><<div class="odocwiki_info"|~Resolvers for promises of type <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.t >>~.


    ~Each resolver can be thought of as the **write end** of one promise~. ~It can
    be passed to <<a_api | val Lwt.wakeup_later >>~, <<a_api | val Lwt.wakeup_later_exn >>~, or
    <<a_api | val Lwt.wakeup_later_result >> to resolve that promise~.
>>
<<pre id="VALtask" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|task>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> * 'a <<a_api text="u" | type Lwt.u >>>>>><<div class="odocwiki_info"|~Creates a new pending [[ #TYPEt| promise]]~, paired with its [[ #TYPEu|
    resolver]]~.


    ~It is rare to use this function directly~. ~Many helpers in ~Lwt~, and ~Lwt~-aware
    libraries~, call it internally~, and return only the promise~. ~You then chain
    the promises together using <<a_api | val Lwt.bind >>~.


    ~However~, it is important to understand <<span class="odocwiki_inlinecode"|~Lwt~.task>> as the fundamental promise
    “constructor~.” ~All other functions that evaluate to a promise can be~, or
    are~, eventually implemented in terms of it~.
>>


===@@id="3_Resolving"@@~Resolving===

<<pre id="VALwakeup_later" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup~_later>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later r v>> //fulfills//~, with value <<span class="odocwiki_inlinecode"|v>>~, the //pending//
    [[ #TYPEt| promise]] associated with [[ #TYPEu| resolver]] <<span class="odocwiki_inlinecode"|r>>~. ~This
    triggers callbacks attached to the promise~.


    ~If the promise is not pending~, <<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later>> raises
    [[ https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinvalid_arg|
    <<span class="odocwiki_inlinecode"|~Pervasives~.~Invalid~_argument>>]]~, unless the promise is [[ #VALcancel|
    canceled]]~. ~If the promise is canceled~, <<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later>> has no effect~.
>>
<<pre id="VALwakeup_later_exn" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup~_later~_exn>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> exn <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later~_exn r exn>> is like <<a_api | val Lwt.wakeup_later >>~, except~, if the
    associated [[ #TYPEt| promise]] is //pending//~, it is //rejected// with
    <<span class="odocwiki_inlinecode"|exn>>~.
>>
<<pre id="VALreturn" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return v>> creates a new [[ #TYPEt| promise]] that is //already
    fulfilled// with value <<span class="odocwiki_inlinecode"|v>>~.


    ~This is needed to satisfy the type system in some cases~. ~For example~, in a
    <<span class="odocwiki_inlinecode"|match>> expression where one case evaluates to a promise~, the other cases
    have to evaluate to promises as well~:



<<code language='ocaml'|match need_input with
| true -> Lwt_io.(read_line stdin)   (* Has type string Lwt.t... *)
| false -> Lwt.return ""             (* ...so wrap empty string in a promise. *)
>>



    ~Another typical usage is in [[ #VALbind| <<span class="odocwiki_inlinecode"|let~%lwt>>]]~. ~The expression after
    the “<<span class="odocwiki_inlinecode"|in>>” has to evaluate to a promise~. ~So~, if you compute an ordinary
    value instead~, you have to wrap it~:



<<code language='ocaml'|let%lwt line = Lwt_io.(read_line stdin) in
Lwt.return (line ^ ".")
>>

>>
<<pre id="VALfail" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|fail>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|exn <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.fail exn>> is like <<a_api | val Lwt.return >>~, except the new [[ #TYPEt| promise]]
    that is //already rejected// with <<span class="odocwiki_inlinecode"|exn>>~.
>>


===@@id="3_Callbacks"@@~Callbacks===

<<pre id="VALbind" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|bind>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.bind p~_~1 f>> makes it so that <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p~_~1>> is [[ #TYPEt|
    //fulfilled//]]~.


    ~When <<span class="odocwiki_inlinecode"|p~_~1>> is fulfilled with value <<span class="odocwiki_inlinecode"|v~_~1>>~, the callback <<span class="odocwiki_inlinecode"|f>> is called with
    that same value <<span class="odocwiki_inlinecode"|v~_~1>>~. ~Eventually~, after perhaps starting some ~I~/~O or other
    computation~, <<span class="odocwiki_inlinecode"|f>> returns promise <<span class="odocwiki_inlinecode"|p~_~2>>~.


    <<span class="odocwiki_inlinecode"|~Lwt~.bind>> itself returns immediately~. ~It only attaches the callback <<span class="odocwiki_inlinecode"|f>> to
    <<span class="odocwiki_inlinecode"|p~_~1>> – it does not wait for <<span class="odocwiki_inlinecode"|p~_~2>>~. //~What// <<span class="odocwiki_inlinecode"|~Lwt~.bind>> returns is yet a
    third promise~, <<span class="odocwiki_inlinecode"|p~_~3>>~. ~Roughly speaking~, fulfillment of <<span class="odocwiki_inlinecode"|p~_~3>> represents both
    <<span class="odocwiki_inlinecode"|p~_~1>> and <<span class="odocwiki_inlinecode"|p~_~2>> becoming fulfilled~, one after the other~.


    ~A minimal example of this is an echo program~:



<<code language='ocaml'|let () =
  let p_3 =
    Lwt.bind
      Lwt_io.(read_line stdin)
      (fun line -> Lwt_io.printl line)
  in
  Lwt_main.run p_3

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~Rejection of <<span class="odocwiki_inlinecode"|p~_~1>> and <<span class="odocwiki_inlinecode"|p~_~2>>~, and raising an exception in <<span class="odocwiki_inlinecode"|f>>~, are all
    forwarded to rejection of <<span class="odocwiki_inlinecode"|p~_~3>>~.


    **~Precise behavior**


    <<span class="odocwiki_inlinecode"|~Lwt~.bind>> returns a promise <<span class="odocwiki_inlinecode"|p~_~3>> immediately~. <<span class="odocwiki_inlinecode"|p~_~3>> starts out pending~,
    and is resolved as follows~:


* ~The first condition to wait for is that <<span class="odocwiki_inlinecode"|p~_~1>> becomes resolved~. ~It does
      not matter whether <<span class="odocwiki_inlinecode"|p~_~1>> is already resolved when <<span class="odocwiki_inlinecode"|~Lwt~.bind>> is called~, or
      becomes resolved later – the rest of the behavior is the same~.
* ~If and when <<span class="odocwiki_inlinecode"|p~_~1>> becomes resolved~, it will~, by definition~, be either
      fulfilled or rejected~.
* ~If <<span class="odocwiki_inlinecode"|p~_~1>> is rejected~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with the same exception~.
* ~If <<span class="odocwiki_inlinecode"|p~_~1>> is fulfilled~, with value <<span class="odocwiki_inlinecode"|v>>~, <<span class="odocwiki_inlinecode"|f>> is applied to <<span class="odocwiki_inlinecode"|v>>~.
* <<span class="odocwiki_inlinecode"|f>> may finish by returning the promise <<span class="odocwiki_inlinecode"|p~_~2>>~, or raising an exception~.
* ~If <<span class="odocwiki_inlinecode"|f>> raises an exception~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with that exception~.
* ~Finally~, the remaining case is when <<span class="odocwiki_inlinecode"|f>> returns <<span class="odocwiki_inlinecode"|p~_~2>>~. ~From that point on~,
      <<span class="odocwiki_inlinecode"|p~_~3>> is effectively made into a reference to <<span class="odocwiki_inlinecode"|p~_~2>>~. ~This means they have
      the same state~, undergo the same state changes~, and performing any
      operation on one is equivalent to performing it on the other~.

    **~Syntactic sugar**


    <<span class="odocwiki_inlinecode"|~Lwt~.bind>> is almost never written directly~, because sequences of <<span class="odocwiki_inlinecode"|~Lwt~.bind>>
    result in growing indentation and many parentheses~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    Lwt.bind Lwt_io.(read_line stdin) (fun line ->
      Lwt.bind (Lwt_unix.sleep 1.) (fun () ->
        Lwt_io.printf "One second ago, you entered %s\n" line))
  end

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~The recommended way to write <<span class="odocwiki_inlinecode"|~Lwt~.bind>> is using the <<span class="odocwiki_inlinecode"|let~%lwt>> syntactic
    sugar~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let%lwt line = Lwt_io.(read_line stdin) in
    let%lwt () = Lwt_unix.sleep 1. in
    Lwt_io.printf "One second ago, you entered %s\n" line
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~This uses the ~Lwt [[ Ppx_lwt.html| ~P~P~X]] ~(preprocessor~)~. ~Note that we had to
    add package <<span class="odocwiki_inlinecode"|lwt~_ppx>> to the command line for building this program~. ~We will
    do that throughout this manual~.


    ~Another way to write <<span class="odocwiki_inlinecode"|~Lwt~.bind>>~, that you may encounter while reading code~,
    is with the <<span class="odocwiki_inlinecode"|~>~>~=>> operator~:



<<code language='ocaml'|open Lwt.Infix

let () =
  Lwt_main.run begin
    Lwt_io.(read_line stdin) ~>>= fun line ->
    Lwt_unix.sleep 1. ~>>= fun () ->
    Lwt_io.printf "One second ago, you entered %s\n" line
  end

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~The <<span class="odocwiki_inlinecode"|~>~>~=>> operator comes from the module <<a_api | module Lwt.Infix >>~, which is why we
    opened it at the beginning of the program~.


    ~See also <<a_api | val Lwt.map >>~.
>>


==@@id="2_Rejection"@@~Rejection==

<<pre id="VALcatch" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|catch>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>exn <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.catch f h>> applies <<span class="odocwiki_inlinecode"|f ~(~)>>~, which returns a promise~, and then makes it
    so that <<span class="odocwiki_inlinecode"|h>> ~(“handler”~) will run when that promise is [[ #TYPEt|
    //rejected//]]~.



<<code language='ocaml'|let () =
  Lwt_main.run begin
    Lwt.catch
      (fun () -> Lwt.fail Pervasives.Exit)
      (function
      | Pervasives.Exit -> Lwt_io.printl "Got Pervasives.Exit"
      | exn -> Lwt.fail exn)
  end

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~Despite the above code~, the recommended way to write <<span class="odocwiki_inlinecode"|~Lwt~.catch>> is using
    the <<span class="odocwiki_inlinecode"|try~%lwt>> syntactic sugar from the [[ Ppx_lwt.html| ~P~P~X]]~. ~Here is an
    equivalent example~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    try%lwt Lwt.fail Pervasives.Exit
    with Pervasives.Exit -> Lwt_io.printl "Got Pervasives.Exit"
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~A particular advantage of the ~P~P~X syntax is that it is not necessary to
    artificially insert a catch~-all <<span class="odocwiki_inlinecode"|exn ~-~> ~Lwt~.fail exn>> case~. ~Like in the core
    language~'s <<span class="odocwiki_inlinecode"|try>> expression~, the catch~-all case is implied in <<span class="odocwiki_inlinecode"|try~%lwt>>~.


    <<span class="odocwiki_inlinecode"|~Lwt~.catch>> is a counterpart to <<a_api | val Lwt.bind >> – <<a_api | val Lwt.bind >> is for
    fulfillment~, and <<a_api | val Lwt.catch >> is for rejection~.


    ~As with <<a_api | val Lwt.bind >>~, three promises are involved~:


* <<span class="odocwiki_inlinecode"|p~_~1>>~, the promise returned from applying <<span class="odocwiki_inlinecode"|f ~(~)>>~.
* <<span class="odocwiki_inlinecode"|p~_~2>>~, the promise returned from applying <<span class="odocwiki_inlinecode"|h exn>>~.
* <<span class="odocwiki_inlinecode"|p~_~3>>~, the promise returned by <<span class="odocwiki_inlinecode"|~Lwt~.catch>> itself~.

    ~The remainder is ~(~1~) a precise description of how <<span class="odocwiki_inlinecode"|p~_~3>> is resolved~, and
    ~(~2~) a warning about accidentally using ordinary <<span class="odocwiki_inlinecode"|try>> for exception handling
    in asynchronous code~.


    **~(~1~)** <<span class="odocwiki_inlinecode"|~Lwt~.catch>> first applies <<span class="odocwiki_inlinecode"|f ~(~)>>~. ~It then returns <<span class="odocwiki_inlinecode"|p~_~3>> immediately~.
    <<span class="odocwiki_inlinecode"|p~_~3>> starts out pending~. ~It is resolved as follows~:


* ~If <<span class="odocwiki_inlinecode"|f ~(~)>> returned a promise <<span class="odocwiki_inlinecode"|p~_~1>>~, and <<span class="odocwiki_inlinecode"|p~_~1>> becomes fulfilled~, <<span class="odocwiki_inlinecode"|p~_~3>> is
      fulfilled with the same value~.
* <<span class="odocwiki_inlinecode"|p~_~1>> can instead become rejected~. ~There is one other possibility~: <<span class="odocwiki_inlinecode"|f ~(~)>>
      itself raised an exception~, instead of returning a promise~. ~The behavior
      of <<span class="odocwiki_inlinecode"|~Lwt~.catch>> is the same whether <<span class="odocwiki_inlinecode"|f ~(~)>> raised an exception~, or returned
      a promise that is later rejected with an exception~. ~Let~'s call the
      exception <<span class="odocwiki_inlinecode"|exn>>~.
* <<span class="odocwiki_inlinecode"|h exn>> is applied~.
* <<span class="odocwiki_inlinecode"|h exn>> may return a promise~, or might itself raise an exception~. ~The
      first case is the interesting one~, but the exception case is simple~, so we
      cover the exception case first~.
* ~If <<span class="odocwiki_inlinecode"|h exn>> raises another exception <<span class="odocwiki_inlinecode"|exn~'>>~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with <<span class="odocwiki_inlinecode"|exn~'>>~.
* ~If <<span class="odocwiki_inlinecode"|h exn>> instead returns the promise <<span class="odocwiki_inlinecode"|p~_~2>>~, <<span class="odocwiki_inlinecode"|p~_~3>> is effectively made
      into a reference to <<span class="odocwiki_inlinecode"|p~_~2>>~. ~This means <<span class="odocwiki_inlinecode"|p~_~3>> and <<span class="odocwiki_inlinecode"|p~_~2>> have the same state~,
      undergo the same state changes~, and performing any operation one is
      equivalent to performing it on the other~.

    **~(~2~)** **~Warning**~: it may be tempting to write this code~, which differs
    from the second example above only in that <<span class="odocwiki_inlinecode"|try>> is used instead of
    <<span class="odocwiki_inlinecode"|try~%lwt>>~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    try Lwt.fail Pervasives.Exit
    with Pervasives.Exit -> Lwt_io.printl "Got Pervasives.Exit"
  end

(* ocamlfind opt -linkpkg -package lwt.unix code.ml && ./a.out *)
>>



    ~This does //not// handle the exception and does not print the message~.
    ~Instead~, it terminates the program with an unhandled <<span class="odocwiki_inlinecode"|~Pervasives~.~Exit>>~.


    ~This is because the call to <<a_api | val Lwt.fail >> creates a rejected promise~. ~The
    promise is still an ordinary ~O~Caml value~, though~, and not a //raised//
    exception~. ~So~, <<span class="odocwiki_inlinecode"|try>> considers that code to have succeeded~, and doesn~'t run
    the handler~. ~When that rejected promise reaches <<a_api | val Lwt_main.run >>~,
    it is <<a_api | val Lwt_main.run >> that raises the exception~.


    ~Basically~, the rule is~: if the code inside <<span class="odocwiki_inlinecode"|try>> evaluates to a promise
    ~(has type <<span class="odocwiki_inlinecode"|~_ ~Lwt~.t>>~)~, replace <<span class="odocwiki_inlinecode"|try>> by <<span class="odocwiki_inlinecode"|try~%lwt>>~.
>>
<<pre id="VALfinalize" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|finalize>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> unit <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.finalize f c>> applies <<span class="odocwiki_inlinecode"|f ~(~)>>~, which returns a promise~, and then makes
    it so <<span class="odocwiki_inlinecode"|c>> ~(“cleanup”~) will run when that promise is [[ #TYPEt|
    //resolved//]]~.


    ~In other words~, <<span class="odocwiki_inlinecode"|c>> runs no matter whether promise <<span class="odocwiki_inlinecode"|f ~(~)>> is fulfilled or
    rejected~. ~As the names suggest~, <<span class="odocwiki_inlinecode"|~Lwt~.finalize>> corresponds to the <<span class="odocwiki_inlinecode"|finally>>
    construct found in many programming languages~, and <<span class="odocwiki_inlinecode"|c>> is typically used for
    cleaning up resources~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let%lwt file = Lwt_io.(open_file Input "code.ml") in
    Lwt.finalize
      (fun () ->
        let%lwt content = Lwt_io.read file in
        Lwt_io.print content)
      (fun () ->
        Lwt_io.close file)
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~As with <<a_api | val Lwt.bind >> and <<a_api | val Lwt.catch >>~, there is a syntactic sugar for
    <<span class="odocwiki_inlinecode"|~Lwt~.finalize>>~, though it is not as often used~:



<<code language='ocaml'|let () =
  Lwt_main.run begin
    let%lwt file = Lwt_io.(open_file Input "code.ml") in
    begin
      let%lwt content = Lwt_io.read file in
      Lwt_io.print content
    end
    [%lwt.finally
      Lwt_io.close file]
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~Also as with <<a_api | val Lwt.bind >> and <<a_api | val Lwt.catch >>~, three promises are involved~:


* <<span class="odocwiki_inlinecode"|p~_~1>>~, the promise returned from applying <<span class="odocwiki_inlinecode"|f ~(~)>>~.
* <<span class="odocwiki_inlinecode"|p~_~2>>~, the promise returned from applying <<span class="odocwiki_inlinecode"|c ~(~)>>~.
* <<span class="odocwiki_inlinecode"|p~_~3>>~, the promise returned by <<span class="odocwiki_inlinecode"|~Lwt~.finalize>> itself~.

    <<span class="odocwiki_inlinecode"|p~_~3>> is returned immediately~. ~It starts out pending~, and is resolved as
    follows~:


* <<span class="odocwiki_inlinecode"|f ~(~)>> is applied~. ~If it finishes~, it will either return a promise <<span class="odocwiki_inlinecode"|p~_~1>>~,
      or raise an exception~.
* ~If <<span class="odocwiki_inlinecode"|f ~(~)>> raises an exception~, <<span class="odocwiki_inlinecode"|p~_~1>> is created artificially as a promise
      rejected with that exception~. ~So~, no matter how <<span class="odocwiki_inlinecode"|f ~(~)>> finishes~, there is
      a promise <<span class="odocwiki_inlinecode"|p~_~1>> representing the outcome~.
* ~After <<span class="odocwiki_inlinecode"|p~_~1>> is resolved ~(fulfilled or rejected~)~, <<span class="odocwiki_inlinecode"|c ~(~)>> is applied~. ~This
      is meant to be the cleanup code~.
* ~If <<span class="odocwiki_inlinecode"|c ~(~)>> finishes~, it will also either return a promise~, <<span class="odocwiki_inlinecode"|p~_~2>>~, or raise
      an exception~.
* ~If <<span class="odocwiki_inlinecode"|c ~(~)>> raises an exception~, <<span class="odocwiki_inlinecode"|p~_~2>> is created artificially as a promise
      rejected with that exception~. ~Again~, no matter how <<span class="odocwiki_inlinecode"|c ~(~)>> finishes~, there
      is a promise <<span class="odocwiki_inlinecode"|p~_~2>> representing the outcome of cleanup~.
* ~If <<span class="odocwiki_inlinecode"|p~_~2>> is fulfilled~, <<span class="odocwiki_inlinecode"|p~_~3>> is resolved the same way <<span class="odocwiki_inlinecode"|p~_~1>> had been
      resolved~. ~In other words~, <<span class="odocwiki_inlinecode"|p~_~1>> is forwarded to <<span class="odocwiki_inlinecode"|p~_~2>> when cleanup is
      successful~.
* ~If <<span class="odocwiki_inlinecode"|p~_~2>> is rejected~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with the same exception~. ~In other
      words~, when cleanup fails~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected~. ~Note this means that if
      //both// the protected code and the cleanup fail~, the cleanup exception
      has precedence~.

>>
<<pre id="VALtry_bind" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|try~_bind>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|\\  <<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >>\\  <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>exn <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.try~_bind f g h>> applies <<span class="odocwiki_inlinecode"|f ~(~)>>~, and then makes it so that~:


* <<span class="odocwiki_inlinecode"|g>> will run when promise <<span class="odocwiki_inlinecode"|f ~(~)>> is [[ #TYPEt| //fulfilled//]]~,
* <<span class="odocwiki_inlinecode"|h>> will run when promise <<span class="odocwiki_inlinecode"|f ~(~)>> is~, alternatively~, [[ #TYPEt|
      //rejected//]]~.

    <<span class="odocwiki_inlinecode"|~Lwt~.try~_bind>> is a generalized <<a_api | val Lwt.finalize >>~. ~The difference is that
    <<span class="odocwiki_inlinecode"|~Lwt~.try~_bind>> runs different callbacks depending on //how// <<span class="odocwiki_inlinecode"|f ~(~)>> is
    resolved~. ~This has two main implications~:


* ~The cleanup functions <<span class="odocwiki_inlinecode"|g>> and <<span class="odocwiki_inlinecode"|h>> each “know” whether <<span class="odocwiki_inlinecode"|f ~(~)>> was fulfilled
      or rejected~.
* ~The cleanup functions <<span class="odocwiki_inlinecode"|g>> and <<span class="odocwiki_inlinecode"|h>> are passed the value <<span class="odocwiki_inlinecode"|f ~(~)>> was
      fulfilled with~, and~, respectively~, the exception <<span class="odocwiki_inlinecode"|f ~(~)>> was rejected
      with~.

    ~The rest is a detailed description of the promises involved~.


    ~As with <<a_api | val Lwt.finalize >> and the several preceding functions~, three promises
    are involved~.


* <<span class="odocwiki_inlinecode"|p~_~1>> is the promise returned from applying <<span class="odocwiki_inlinecode"|f ~(~)>>~.
* <<span class="odocwiki_inlinecode"|p~_~2>> is the promise returned from applying <<span class="odocwiki_inlinecode"|h>> or <<span class="odocwiki_inlinecode"|g>>~, depending on which
      one is chosen~.
* <<span class="odocwiki_inlinecode"|p~_~3>> is the promise returned by <<span class="odocwiki_inlinecode"|~Lwt~.try~_bind>> itself~.

    <<span class="odocwiki_inlinecode"|~Lwt~.try~_bind>> returns <<span class="odocwiki_inlinecode"|p~_~3>> immediately~. <<span class="odocwiki_inlinecode"|p~_~3>> starts out pending~, and is
    resolved as follows~:


* <<span class="odocwiki_inlinecode"|f ~(~)>> is applied~. ~If it finishes~, it either returns <<span class="odocwiki_inlinecode"|p~_~1>>~, or raises an
      exception~.
* ~If <<span class="odocwiki_inlinecode"|f ~(~)>> raises an exception~, <<span class="odocwiki_inlinecode"|p~_~1>> is created artificially as a promise
      rejected with that exception~. ~So~, no matter how <<span class="odocwiki_inlinecode"|f ~(~)>> finishes~, there is
      a promise <<span class="odocwiki_inlinecode"|p~_~1>> representing the outcome~.
* ~If <<span class="odocwiki_inlinecode"|p~_~1>> is fulfilled~, <<span class="odocwiki_inlinecode"|g>> is applied to the value <<span class="odocwiki_inlinecode"|p~_~1>> is fulfilled
      with~.
* ~If <<span class="odocwiki_inlinecode"|p~_~1>> is rejected~, <<span class="odocwiki_inlinecode"|h>> is applied to the exception <<span class="odocwiki_inlinecode"|p~_~1>> is rejected
      with~.
* ~So~, in either case~, a callback is applied~. ~The rest of the procedure is
      the same no matter which callback was chosen~, so we will refer to it as
      “the callback~.”
* ~If the callback finishes~, it either returns <<span class="odocwiki_inlinecode"|p~_~2>>~, or raises an exception~.
* ~If the callback raises an exception~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with that
      exception~.
* ~If the callback returns <<span class="odocwiki_inlinecode"|p~_~2>>~, <<span class="odocwiki_inlinecode"|p~_~3>> is effectively made into an reference
      to <<span class="odocwiki_inlinecode"|p~_~2>>~. ~They have the same state~, including any state changes~, and
      performing any operation on one is equivalent to performing it on the
      other~.

>>
<<pre id="VALasync" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|async>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.async f>> applies <<span class="odocwiki_inlinecode"|f ~(~)>>~, which returns a promise~, and then makes it so
    that if the promise is [[ #TYPEt| //rejected//]]~, the exception is passed to
    <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.


    ~In addition~, if <<span class="odocwiki_inlinecode"|f ~(~)>> raises an exception~, it is also passed to
    <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.


    <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >> typically prints an error message and
    terminates the program~.


    <<span class="odocwiki_inlinecode"|~Lwt~.async>> is misleadingly named~. ~Itself~, it has nothing to do with
    asynchronous execution~. ~It~'s actually a safety function for making ~Lwt
    programs more debuggable~.


    ~For example~, take this program~, which prints messages in a loop~, while
    waiting for one line of user input~:



<<code language='ocaml'|let () =
  let rec show_nag () : _ Lwt.t =
    let%lwt () = Lwt_io.printl "Please enter a line" in
    let%lwt () = Lwt_unix.sleep 1. in
    show_nag ()
  in
  ignore (show_nag ());     (* Bad – see note for (1)! *)

  Lwt_main.run begin
    let%lwt line = Lwt_io.(read_line stdin) in
    Lwt_io.printl line
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~If one of the ~I~/~O operations in <<span class="odocwiki_inlinecode"|show~_nag>> were to fail~, the promise
    representing the whole loop would get rejected~. ~However~, since we are
    ignoring that promise at **~(~1~)**~, we never find out about the rejection~. ~If
    this failure and resulting rejection represents a bug in the program~, we
    have a harder time finding out about the bug~.


    ~A safer version differs only in using <<span class="odocwiki_inlinecode"|~Lwt~.async>> instead of
    <<span class="odocwiki_inlinecode"|~Pervasives~.ignore>>~:



<<code language='ocaml'|let () =
  let rec show_nag () : _ Lwt.t =
    let%lwt () = Lwt_io.printl "Please enter a line" in
    let%lwt () = Lwt_unix.sleep 1. in
    show_nag ()
  in
  Lwt.async (fun () -> show_nag ());

  Lwt_main.run begin
    let%lwt line = Lwt_io.(read_line stdin) in
    Lwt_io.printl line
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~In this version~, if ~I~/~O in <<span class="odocwiki_inlinecode"|show~_nag>> fails with an exception~, the exception
    is printed by <<span class="odocwiki_inlinecode"|~Lwt~.async>>~, and then the program exits~.


    ~The general rule for when to use <<span class="odocwiki_inlinecode"|~Lwt~.async>> is~:


* ~Promises which are //not// passed //to// <<a_api | val Lwt.bind >>~, <<a_api | val Lwt.catch >>~,
      <<a_api | val Lwt.join >>~, etc~.~, are **top~-level** promises~.
* ~One top~-level promise is passed to <<a_api | val Lwt_main.run >>~, as can be seen in most
      examples in this manual~.
* ~Every other top~-level promise should be wrapped in <<span class="odocwiki_inlinecode"|~Lwt~.async>>~.

>>
<<pre id="VALasync_exception_hook" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|async~_exception~_hook>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>exn <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_uid"|Pervasives>><<span class="ocsforge_color_delimiter"| . >><<span class="ocsforge_color_lid"|ref>>>>>><<div class="odocwiki_info"|~Reference to a function~, to be called on an "unhandled" exception~.


    ~This reference is used by <<a_api | val Lwt.async >>~, <<a_api | val Lwt.on_cancel >>~, <<a_api | val Lwt.on_success >>~,
    <<a_api | val Lwt.on_failure >>~, <<a_api | val Lwt.on_termination >>~, <<a_api | val Lwt.on_any >>~, and the deprecated
    <<a_api | val Lwt.ignore_result >>~.


    ~The initial~, default implementation prints the exception~, then terminates
    the process with non~-zero exit status~, as if the exception had reached the
    top level of the program~:



<<code language='ocaml'|let () = Lwt.async (fun () -> Lwt.fail Pervasives.Exit)

(* ocamlfind opt -linkpkg -package lwt code.ml && ./a.out *)
>>



    produces in the output~:


{{{Fatal error: exception Pervasives.Exit}}}


    ~If you are writing an application~, you are welcome to reassign the
    reference~, and replace the function with something more appropriate for your
    needs~.


    ~If you are writing a library~, you should leave this reference alone~. ~Its
    behavior should be determined by the application~.
>>


==@@id="2_Concurrency"@@~Concurrency==



===@@id="3_Multiplewait"@@~Multiple wait===

<<pre id="VALjoin" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|join>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> unit <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.join ps>> returns a promise that is pending until //all// promises in
    the list <<span class="odocwiki_inlinecode"|ps>> become [[ #TYPEt| //resolved//]]~.



<<code language='ocaml'|let () =
  let p_1 =
    let%lwt () = Lwt_unix.sleep 3. in
    Lwt_io.printl "Three seconds elapsed"
  in

  let p_2 =
    let%lwt () = Lwt_unix.sleep 5. in
    Lwt_io.printl "Five seconds elapsed"
  in

  let p_3 = Lwt.join [p_1; p_2] in
  Lwt_main.run p_3

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~If all of the promises in <<span class="odocwiki_inlinecode"|ps>> become fulfilled~, <<span class="odocwiki_inlinecode"|~Lwt~.join ps>> is also
    fulfilled~. ~Otherwise~, if at least one promise in <<span class="odocwiki_inlinecode"|ps>> becomes rejected~,
    <<span class="odocwiki_inlinecode"|~Lwt~.join ps>> is rejected with the same exception as one such promise~,
    chosen arbitrarily~. ~Note that this occurs only after all the promises are
    resolved~, not immediately when the first promise is rejected~.
>>


===@@id="3_Racing"@@~Racing===

<<pre id="VALpick" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|pick>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.pick ps>> returns a promise that is pending until //one// promise in
    the list <<span class="odocwiki_inlinecode"|ps>> becomes [[ #TYPEt| //resolved//]]~.


    ~When at least one promise in <<span class="odocwiki_inlinecode"|ps>> is resolved~, <<span class="odocwiki_inlinecode"|~Lwt~.pick>> tries to cancel
    all other promises that are still pending~, using <<a_api | val Lwt.cancel >>~.



<<code language='ocaml'|let () =
  let echo =
    let%lwt line = Lwt_io.(read_line stdin) in
    Lwt_io.printl line
  in

  let timeout = Lwt_unix.sleep 5. in

  Lwt_main.run (Lwt.pick [echo; timeout])

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~If the first promise in <<span class="odocwiki_inlinecode"|ps>> to become resolved is fulfilled~, the result
    promise <<span class="odocwiki_inlinecode"|p>> is also fulfilled~, with the same value~. ~Likewise~, if the first
    promise in <<span class="odocwiki_inlinecode"|ps>> to become resolved is rejected~, <<span class="odocwiki_inlinecode"|p>> is rejected with the
    same exception~.


    ~If <<span class="odocwiki_inlinecode"|ps>> has no promises ~(if it is the empty list~)~, <<span class="odocwiki_inlinecode"|~Lwt~.pick ps>> returns a
    promise that is pending forever~, and cannot be canceled~.


    ~It~'s possible for multiple promises in <<span class="odocwiki_inlinecode"|ps>> to become resolved
    simultaneously~. ~This happens most often when some promises <<span class="odocwiki_inlinecode"|ps>> are already
    resolved at the time <<span class="odocwiki_inlinecode"|~Lwt~.pick>> is called~.


    ~In that case~, if at least one of the promises is rejected~, the result
    promise <<span class="odocwiki_inlinecode"|p>> is rejected with the same exception as one such promise~, chosen
    arbitrarily~. ~If all promises are fulfilled~, <<span class="odocwiki_inlinecode"|p>> is fulfilled with the value
    of one of the promises~, also chosen arbitrarily~.


    ~The remaining functions in this section are variations on <<span class="odocwiki_inlinecode"|~Lwt~.pick>>~.
>>
<<pre id="VALchoose" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|choose>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.choose ps>> is the same as <<a_api | val Lwt.pick >><<span class="odocwiki_inlinecode"| ps>>~, except that it does not try
    to cancel pending promises in <<span class="odocwiki_inlinecode"|ps>>~.
>>
<<pre id="VALnpick" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|npick>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> 'a list <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.npick ps>> is similar to <<a_api | val Lwt.pick >><<span class="odocwiki_inlinecode"| ps>>~, the difference being that
    when multiple promises in <<span class="odocwiki_inlinecode"|ps>> are fulfilled simultaneously ~(and none are
    rejected~)~, the result promise is fulfilled with the //list// of values the
    promises were fulfilled with~.


    ~When at least one promise is rejected~, <<span class="odocwiki_inlinecode"|~Lwt~.npick>> still rejects the result
    promise with the same exception~.
>>
<<pre id="VALnchoose" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|nchoose>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> 'a list <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.nchoose ps>> is the same as <<a_api | val Lwt.npick >><<span class="odocwiki_inlinecode"| ps>>~, except that it does not
    try to cancel pending promises in <<span class="odocwiki_inlinecode"|ps>>~.
>>
<<pre id="VALnchoose_split" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|nchoose~_split>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> list <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a list * 'a <<a_api text="t" | type Lwt.t >> list<<span class="ocsforge_color_delimiter"| ) >> <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.nchoose~_split ps>> is the same as <<a_api | val Lwt.nchoose >><<span class="odocwiki_inlinecode"| ps>>~, except that when
    multiple promises in <<span class="odocwiki_inlinecode"|ps>> are fulfilled simultaneously ~(and none are
    rejected~)~, the result promise is fulfilled with //both// the list of values
    of the fulfilled promises~, and the list of promises that are still
    pending~.
>>


==@@id="2_Cancelation"@@~Cancelation==

<<pre id="EXCEPTIONCanceled" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|exception>> <<span class="odocwiki_name"|Canceled>>>><<div class="odocwiki_info"|~Canceled promises are those rejected with this exception~, <<span class="odocwiki_inlinecode"|~Lwt~.~Canceled>>~.
    ~See <<a_api | val Lwt.cancel >>~.
>>
<<pre id="VALcancel" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|cancel>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.cancel p>> attempts to //cancel// the pending promise <<span class="odocwiki_inlinecode"|p>>~, without
    needing access to its resolver~.


    ~A **canceled** promise is one that has been rejected with exception
    <<a_api | exception Lwt.Canceled >>~.


    ~There are straightforward ways to make promises canceled~. ~One could create a
    promise that //starts out// canceled~, with <<a_api | val Lwt.fail >><<span class="odocwiki_inlinecode"| ~Lwt~.~Canceled>>~. ~It~'s
    also possible to //make// a promise canceled through its resolver~, by
    calling <<a_api | val Lwt.wakeup_later_exn >><<span class="odocwiki_inlinecode"| r ~Lwt~.~Canceled>>~.


    ~This function~, <<span class="odocwiki_inlinecode"|~Lwt~.cancel>>~, provides another method~, which can cancel
    pending promises //without// going through their resolvers – it acts
    directly on promises~.


    ~Like any other promise rejection~, the canceled state of a promise is
    propagated “forwards” by <<a_api | val Lwt.bind >>~, <<a_api | val Lwt.join >>~, etc~.~, as described in the
    documentation of those functions~.


    **~Cancelation** is a separate phase~, triggered only by <<a_api | val Lwt.cancel >>~, that
    searches //backwards//~, strating from <<span class="odocwiki_inlinecode"|p>>~, for promises to reject with
    <<a_api | exception Lwt.Canceled >>~. ~Once those promises are found~, they are canceled~, and then
    ordinary~, forwards rejection propagation takes over~.


    ~All of this will be made precise~, but first let~'s have an example~:



<<code language='ocaml'|let () =
  let p =
    let%lwt () = Lwt_unix.sleep 5. in
    Lwt_io.printl "Slept five seconds"
  in

  Lwt.cancel p;

  Lwt_main.run p

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~At the time <<span class="odocwiki_inlinecode"|~Lwt~.cancel>> is called~, <<span class="odocwiki_inlinecode"|p>> “depends” on the <<span class="odocwiki_inlinecode"|sleep>> promise
    ~(the <<span class="odocwiki_inlinecode"|printl>> is not yet called~, so its promise hasn~'t been created~)~.


    ~So~, <<a_api | val Lwt.cancel >> recursively tries to cancel the <<span class="odocwiki_inlinecode"|sleep>> promise~. ~That is
    an example of the backwards search~. ~The <<span class="odocwiki_inlinecode"|sleep>> promise is a pending promise
    that doesn~'t depend on anything~, so backwards search stops at it~. ~The state
    of the <<span class="odocwiki_inlinecode"|sleep>> promise is set to //rejected// with <<a_api | exception Lwt.Canceled >>~.


    <<a_api | val Lwt.bind >> then propagates the rejection forwards to <<span class="odocwiki_inlinecode"|p>>~, so <<span class="odocwiki_inlinecode"|p>> also
    becomes canceled~.


    ~Eventually~, this rejection reaches <<a_api | val Lwt_main.run >>~, which raises the
    <<a_api | exception Lwt.Canceled >> as an ordinary exception~. ~The <<span class="odocwiki_inlinecode"|sleep>> does not complete~, and
    the <<span class="odocwiki_inlinecode"|printl>> is never started~.


    ~Promises~, like the <<span class="odocwiki_inlinecode"|sleep>> promise above~, that can be rejected by
    <<span class="odocwiki_inlinecode"|~Lwt~.cancel>> are **cancelable**~. ~Most promises in ~Lwt are either cancelable~,
    or depend on cancelable promises~. ~The functions <<a_api | val Lwt.wait >> and
    <<a_api | val Lwt.no_cancel >> create promises that are //not// cancelable~.


    ~The rest is a detailed description of how the <<span class="odocwiki_inlinecode"|~Lwt~.cancel>> backwards search
    works~.


* ~If <<span class="odocwiki_inlinecode"|p>> is already resolved~, <<span class="odocwiki_inlinecode"|~Lwt~.cancel>> does nothing~.
* ~If <<span class="odocwiki_inlinecode"|p>> was created by <<a_api | val Lwt.wait >> or <<a_api | val Lwt.no_cancel >>~, <<span class="odocwiki_inlinecode"|~Lwt~.cancel>> does
      nothing~.
* ~If <<span class="odocwiki_inlinecode"|p>> was created by <<a_api | val Lwt.task >> or <<a_api | val Lwt.protected >>~, <<span class="odocwiki_inlinecode"|~Lwt~.cancel>>
      rejects it with <<span class="odocwiki_inlinecode"|~Lwt~.~Canceled>>~. ~This rejection then propagates normally
      through any ~Lwt calls that depend on <<span class="odocwiki_inlinecode"|p>>~. ~Most ~I~/~O promises are internally
      created by calling <<a_api | val Lwt.task >>~.
* ~Suppose <<span class="odocwiki_inlinecode"|p~_~3>> was returned by <<a_api | val Lwt.bind >>~, <<a_api | val Lwt.map >>~, <<a_api | val Lwt.catch >>~,
      <<a_api | val Lwt.finalize >>~, or <<a_api | val Lwt.try_bind >>~. ~Then~, see those functions for the
      naming of the other promises involved~. ~If <<span class="odocwiki_inlinecode"|p~_~3>> is pending~, then either
      <<span class="odocwiki_inlinecode"|p~_~1>> is pending~, or <<span class="odocwiki_inlinecode"|p~_~2>> is pending~. <<span class="odocwiki_inlinecode"|~Lwt~.cancel p~_~3>> then tries
      recursively to cancel whichever of these two is still pending~. ~If that
      succeeds~, <<span class="odocwiki_inlinecode"|p~_~3>> //may// be canceled later by the normal propagation of
      rejection~.
* ~Suppose <<span class="odocwiki_inlinecode"|p>> was returned by <<a_api | val Lwt.join >>~, <<a_api | val Lwt.pick >>~, or similar function~,
      which was applied to the promise list <<span class="odocwiki_inlinecode"|ps>>~. <<a_api | val Lwt.cancel >> then recursively
      tries to cancel each promise in <<span class="odocwiki_inlinecode"|ps>>~. ~If one of those cancelations
      succeeds~, <<span class="odocwiki_inlinecode"|p>> //may// be canceled later by the normal propagation of
      rejection~.

>>
<<pre id="VALon_cancel" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|on~_cancel>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.on~_cancel p f>> makes it so that <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p>> becomes
    [[ #EXCEPTIONCanceled| //canceled//]]~.


    ~Callbacks scheduled with <<span class="odocwiki_inlinecode"|on~_cancel>> are guaranteed to run before any other
    callbacks that are triggered by rejection~, such as those added by
    <<a_api | val Lwt.catch >>~.


    ~Note that this does not interact directly with the //cancelation//
    mechanism~, the backwards search described in <<a_api | val Lwt.cancel >>~. ~For example~,
    manually rejecting a promise with <<a_api | exception Lwt.Canceled >> is sufficient to trigger
    <<span class="odocwiki_inlinecode"|f>>~.


    <<span class="odocwiki_inlinecode"|f>> should not raise exceptions~. ~If it does~, they are passed to
    <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~, which terminates the process by default~.
>>
<<pre id="VALprotected" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|protected>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.protected p>> creates a [[ #VALcancel| cancelable]] promise <<span class="odocwiki_inlinecode"|p~'>> with
    the same state as <<span class="odocwiki_inlinecode"|p>>~. ~However~, cancelation~, the backwards search described
    in <<a_api | val Lwt.cancel >>~, stops at <<span class="odocwiki_inlinecode"|p~'>>~, and does not continue to <<span class="odocwiki_inlinecode"|p>>~.
>>
<<pre id="VALno_cancel" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|no~_cancel>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.no~_cancel p>> creates a non~-[[ #VALcancel|cancelable]] promise <<span class="odocwiki_inlinecode"|p~'>>~,
    with the same state as <<span class="odocwiki_inlinecode"|p>>~. ~Cancelation~, the backwards search described in
    <<a_api | val Lwt.cancel >>~, stops at <<span class="odocwiki_inlinecode"|p~'>>~, and does not continue to <<span class="odocwiki_inlinecode"|p>>~.


    ~Note that <<span class="odocwiki_inlinecode"|p~'>> can still be canceled if <<span class="odocwiki_inlinecode"|p>> is canceled~. <<span class="odocwiki_inlinecode"|~Lwt~.no~_cancel>>
    only prevents cancelation of <<span class="odocwiki_inlinecode"|p>> and <<span class="odocwiki_inlinecode"|p~'>> through <<span class="odocwiki_inlinecode"|p~'>>~.
>>
<<pre id="VALwait" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wait>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> * 'a <<a_api text="u" | type Lwt.u >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wait>> is the same as <<a_api | val Lwt.task >>~, except the resulting promise <<span class="odocwiki_inlinecode"|p>> is
    //not// [[ #VALcancel| cancelable]]~.


    ~This is significant~, because it means <<span class="odocwiki_inlinecode"|p>> created by <<span class="odocwiki_inlinecode"|~Lwt~.wait>> can //only//
    be resolved through its paired resolver~.


    ~In contrast~, promises returned by <<a_api | val Lwt.task >> can additionally be resolved
    by canceling them directly with <<a_api | val Lwt.cancel >>~.
>>


==@@id="2_Convenience"@@~Convenience==



===@@id="3_Callbackhelpers"@@~Callback helpers===

<<pre id="VALmap" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|map>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.map f p~_~1>> is similar to <<a_api | val Lwt.bind >><<span class="odocwiki_inlinecode"| p~_~1 f>>~, but <<span class="odocwiki_inlinecode"|f>> is not expected
    to return a promise~.


    ~This function is more convenient that <<a_api | val Lwt.bind >> when <<span class="odocwiki_inlinecode"|f>> inherently does
    not return a promise~. ~An example is <<span class="odocwiki_inlinecode"|~Pervasives~.int~_of~_string>>~:



<<code language='ocaml'|let read_int : unit -> int Lwt.t = fun () ->
  Lwt.map
    int_of_string
    Lwt_io.(read_line stdin)

let () =
  Lwt_main.run begin
    let%lwt number = read_int () in
    Lwt_io.printf "%i\n" number
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~By comparison~, the <<a_api | val Lwt.bind >> version is more awkward~:



<<code language='ocaml'|let read_int : unit -> int Lwt.t = fun () ->
  Lwt.bind
    Lwt_io.(read_line stdin)
    (fun line -> Lwt.return (int_of_string line))
>>



    ~As with <<a_api | val Lwt.bind >>~, sequences of calls to <<span class="odocwiki_inlinecode"|~Lwt~.map>> result in excessive
    indentation and parentheses~. ~The recommended syntactic sugar for avoiding
    this is the [[ #VAL(>|=)| <<span class="odocwiki_inlinecode"|~>~|~=>>]] operator~, which comes from module
    <<span class="odocwiki_inlinecode"|~Lwt~.~Infix>>~:



<<code language='ocaml'|open Lwt.Infix

let read_int : unit -> int Lwt.t = fun () ->
  Lwt_io.(read_line stdin) >|= int_of_string
>>



    ~The detailed operation follows~. ~For consistency with the promises in
    <<a_api | val Lwt.bind >>~, the //two// promises involved are named <<span class="odocwiki_inlinecode"|p~_~1>> and <<span class="odocwiki_inlinecode"|p~_~3>>~:


* <<span class="odocwiki_inlinecode"|p~_~1>> is the promise passed to <<span class="odocwiki_inlinecode"|~Lwt~.map>>~.
* <<span class="odocwiki_inlinecode"|p~_~3>> is the promise returned by <<span class="odocwiki_inlinecode"|~Lwt~.map>>~.

    <<span class="odocwiki_inlinecode"|~Lwt~.map>> returns a promise <<span class="odocwiki_inlinecode"|p~_~3>>~. <<span class="odocwiki_inlinecode"|p~_~3>> starts out pending~. ~It is resolved
    as follows~:


* <<span class="odocwiki_inlinecode"|p~_~1>> may be~, or become~, resolved~. ~In that case~, by definition~, it will
      become fulfilled or rejected~. ~Fulfillment is the interesting case~, but the
      behavior on rejection is simpler~, so we focus on rejection first~.
* ~When <<span class="odocwiki_inlinecode"|p~_~1>> becomes rejected~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with the same exception~.
* ~When <<span class="odocwiki_inlinecode"|p~_~1>> instead becomes fulfilled~, call the value it is fulfilled with
      <<span class="odocwiki_inlinecode"|v>>~.
* <<span class="odocwiki_inlinecode"|f v>> is applied~. ~If this finishes~, it may either return another value~, or
      raise an exception~.
* ~If <<span class="odocwiki_inlinecode"|f v>> returns another value <<span class="odocwiki_inlinecode"|v~'>>~, <<span class="odocwiki_inlinecode"|p~_~3>> is fulfilled with <<span class="odocwiki_inlinecode"|v~'>>~.
* ~If <<span class="odocwiki_inlinecode"|f v>> raises exception <<span class="odocwiki_inlinecode"|exn>>~, <<span class="odocwiki_inlinecode"|p~_~3>> is rejected with <<span class="odocwiki_inlinecode"|exn>>~.

>>
<<pre id="VALon_success" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|on~_success>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.on~_success p f>> makes it so that <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt|
    //fulfilled//]]~.


    ~It is similar to <<a_api | val Lwt.bind >>~, except no new promises are created~. <<span class="odocwiki_inlinecode"|f>> is a
    plain~, arbitrary function attached to <<span class="odocwiki_inlinecode"|p>>~, to perform some side effect~.


    ~If <<span class="odocwiki_inlinecode"|f>> raises an exception~, it is passed to <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.
    ~By default~, this will terminate the process~.
>>
<<pre id="VALon_failure" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|on~_failure>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>exn <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.on~_failure p f>> makes it so that <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt|
    //rejected//]]~.


    ~It is similar to <<a_api | val Lwt.catch >>~, except no new promises are created~.


    ~If <<span class="odocwiki_inlinecode"|f>> raises an exception~, it is passed to <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.
    ~By default~, this will terminate the process~.
>>
<<pre id="VALon_termination" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|on~_termination>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.on~_termination p f>> makes it so that <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p>> is
    [[ #TYPEt| //resolved//]] – that is~, fulfilled //or// rejected~.


    ~It is similar to <<a_api | val Lwt.finalize >>~, except no new promises are created~.


    ~If <<span class="odocwiki_inlinecode"|f>> raises an exception~, it is passed to <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.
    ~By default~, this will terminate the process~.
>>
<<pre id="VALon_any" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|on~_any>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>exn <<span class="ocsforge_color_delimiter"| -> >> unit<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.on~_any p f g>> makes it so that~:


* <<span class="odocwiki_inlinecode"|f>> will run when <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt| //fulfilled//]]~,
* <<span class="odocwiki_inlinecode"|g>> will run when <<span class="odocwiki_inlinecode"|p>> is~, alternatively~, [[ #TYPEt| //rejected//]]~.

    ~It is similar to <<a_api | val Lwt.try_bind >>~, except no new promises are created~.


    ~If <<span class="odocwiki_inlinecode"|f>> or <<span class="odocwiki_inlinecode"|g>> raise an exception~, the exception is passed to
    <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~. ~By default~, this will terminate the
    process~.
>>


===@@id="3_Infixoperators"@@~Infix operators===

<<pre class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|module>> <<a_api text="Infix" | module Lwt.Infix >> <<span class="ocsforge_color_delimiter"|~:>> <<span class="ocsforge_color_keyword"|sig>><<a_api text=".." | module Lwt.Infix >><<span class="ocsforge_color_keyword"|end>>>><<div class="odocwiki_info"|~This module provides several infix operators for making programming with
    ~Lwt more convenient~.
>>


===@@id="3_Preallocatedpromises"@@~Pre~-allocated promises===

<<pre id="VALreturn_unit" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_unit>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return~_unit>> is defined as <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~(~)>>~, but this definition is
    evaluated only once~, during initialization of module <<span class="odocwiki_inlinecode"|~Lwt>>~, at the beginning
    of your program~.


    ~This means the promise is allocated only once~. ~By contrast~, each time
    <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~(~)>> is evaluated~, it allocates a new promise~.


    ~It is recommended to use <<span class="odocwiki_inlinecode"|~Lwt~.return~_unit>> only where you know the
    allocations caused by an instance of <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~(~)>> are a performance
    bottleneck~. ~Generally~, the cost of ~I~/~O tends to dominate the cost of
    <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~(~)>> anyway~.


    ~In future ~Lwt~, we hope to perform this optimization~, of using a single~,
    pre~-allocated promise~, automatically~, wherever <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~(~)>> is
    written~.
>>
<<pre id="VALreturn_none" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_none>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a option <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return~_none>> is like <<a_api | val Lwt.return_unit >>~, but for
    <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~None>>~.
>>
<<pre id="VALreturn_nil" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_nil>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a list <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return~_nil>> is like <<a_api | val Lwt.return_unit >>~, but for <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| ~[~]>>~.
>>
<<pre id="VALreturn_true" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_true>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|bool <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return~_true>> is like <<a_api | val Lwt.return_unit >>~, but for
    <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| true>>~.
>>
<<pre id="VALreturn_false" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_false>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|bool <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.return~_false>> is like <<a_api | val Lwt.return_unit >>~, but for
    <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| false>>~.
>>


===@@id="3_Resulttype"@@~Result type===

<<pre class="ocsforge_color odocwiki_code" id="TYPEresult"|<<span class="ocsforge_color_keyword"|type>> <<span class="odocwiki_type"|'a>> <<span class="odocwiki_name"|result>> <<span class="ocsforge_color_delimiter"|~=>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a, exn<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_uid"|Result>><<span class="ocsforge_color_delimiter"| . >><<span class="ocsforge_color_lid"|result>>>> >><<div class="odocwiki_info"|~Representation of the content of a resolved promise of type
    <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.t >>~.


    ~This type is effectively



<<code language='ocaml'|type +'a Lwt.result =
  | Ok of 'a
  | Error of exn
>>



    or~, on ~O~Caml ~4~.~0~2~:



<<code language='ocaml'|type +'a Lwt.result =
  | Result.Ok of 'a
  | Result.Error of exn
>>



    ~A resolved promise of type <<span class="odocwiki_inlinecode"|~'a >><<a_api | type Lwt.t >> is either fulfilled with a value of
    type <<span class="odocwiki_inlinecode"|~'a>>~, or rejected with an exception~.


    ~This corresponds to the cases of a
    <<span class="odocwiki_inlinecode"|~(~'a~, exn~)>>[[ https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult|<<span class="odocwiki_inlinecode"|~Pervasives~.result>>]]~:
    fulfilled corresponds to <<span class="odocwiki_inlinecode"|~Ok of ~'a>>~, and rejected corresponds to
    <<span class="odocwiki_inlinecode"|~Error of exn>>~.


    ~It~'s important to note that this type constructor~, <<span class="odocwiki_inlinecode"|~Lwt~.result>>~, is
    different from <<span class="odocwiki_inlinecode"|~Pervasives~.result>>~. ~It is a specialization of
    <<span class="odocwiki_inlinecode"|~Pervasives~.result>> so that the <<span class="odocwiki_inlinecode"|~Error>> constructor always carries <<span class="odocwiki_inlinecode"|exn>>~.


    ~For ~Lwt programming with <<span class="odocwiki_inlinecode"|result>> where the <<span class="odocwiki_inlinecode"|~Error>> constructor can carry
    arbitrary error types~, see module <<a_api | module Lwt_result >>~.


    ~The naming conflict between <<span class="odocwiki_inlinecode"|~Lwt~.result>> and <<span class="odocwiki_inlinecode"|~Pervasives~.result>> is an
    unfortunate historical accident~. <<span class="odocwiki_inlinecode"|~Pervasives~.result>> did not exist when
    <<span class="odocwiki_inlinecode"|~Lwt~.result>> was created~.


    ~The type <<span class="odocwiki_inlinecode"|~Result~.result>> is equivalent to <<span class="odocwiki_inlinecode"|~Pervasives~.result>> starting from
    ~O~Caml ~4~.~0~3~. ~If you need compatibility with ~O~Caml ~4~.~0~2~, refer to
    <<span class="odocwiki_inlinecode"|~Pervasives~.result>> as <<span class="odocwiki_inlinecode"|~Result~.result>>~, and prefix the constructor names
    with <<span class="odocwiki_inlinecode"|~Result>>~, as shown in the second example~.
>>
<<pre id="VALof_result" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|of~_result>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="result" | type Lwt.result >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.of~_result r>> converts an r to a resolved promise~.


* ~If <<span class="odocwiki_inlinecode"|r>> is <<span class="odocwiki_inlinecode"|~Ok v>>~, <<span class="odocwiki_inlinecode"|~Lwt~.of~_result r>> is <<span class="odocwiki_inlinecode"|~Lwt~.return v>>~, i~.e~. a promise
      fulfilled with <<span class="odocwiki_inlinecode"|v>>~.
* ~If <<span class="odocwiki_inlinecode"|r>> is <<span class="odocwiki_inlinecode"|~Error exn>>~, <<span class="odocwiki_inlinecode"|~Lwt~.of~_result r>> is <<span class="odocwiki_inlinecode"|~Lwt~.fail exn>>~, i~.e~. a promise
      rejected with <<span class="odocwiki_inlinecode"|exn>>~.

>>
<<pre id="VALwakeup_later_result" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup~_later~_result>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="result" | type Lwt.result >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later~_result r result>> resolves the pending promise <<span class="odocwiki_inlinecode"|p>>
    associated to resolver <<span class="odocwiki_inlinecode"|r>>~, according to <<span class="odocwiki_inlinecode"|result>>~:


* ~If <<span class="odocwiki_inlinecode"|result>> is <<span class="odocwiki_inlinecode"|~Ok v>>~, <<span class="odocwiki_inlinecode"|p>> is fulfilled with <<span class="odocwiki_inlinecode"|v>>~.
* ~If <<span class="odocwiki_inlinecode"|result>> is <<span class="odocwiki_inlinecode"|~Error exn>>~, <<span class="odocwiki_inlinecode"|p>> is rejected with <<span class="odocwiki_inlinecode"|exn>>~.

    ~If <<span class="odocwiki_inlinecode"|p>> is not pending~, <<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later~_result>> raises
    <<span class="odocwiki_inlinecode"|~Pervasives~.~Invalid~_argument ~_>>~, except if <<span class="odocwiki_inlinecode"|p>> is [[ #VALcancel| canceled]]~.
    ~If <<span class="odocwiki_inlinecode"|p>> is canceled~, <<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_later~_result>> has no effect~.
>>


===@@id="3_Statequery"@@~State query===

<<pre class="ocsforge_color odocwiki_code" id="TYPEstate"|<<span class="ocsforge_color_keyword"|type>> <<span class="odocwiki_type"|'a>> <<span class="odocwiki_name"|state>> <<span class="ocsforge_color_delimiter"|~=>> <<span class="odocwiki_variants"|<<span class="odocwiki_variant"|<<span class="odocwiki_variant_constr"|<<span class="ocsforge_color_keyword"| ~|>> <<span class="ocsforge_color_uid"|Return>> <<span class="ocsforge_color_keyword"|of>> <<span class="odocwiki_type"|'a>>>>>><<span class="odocwiki_variant"|<<span class="odocwiki_variant_constr"|<<span class="ocsforge_color_keyword"| ~|>> <<span class="ocsforge_color_uid"|Fail>> <<span class="ocsforge_color_keyword"|of>> <<span class="odocwiki_type"|exn>>>>>><<span class="odocwiki_variant"|<<span class="odocwiki_variant_constr"|<<span class="ocsforge_color_keyword"| ~|>> <<span class="ocsforge_color_uid"|Sleep>>>>>>>>>><<pre id="VALstate" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|state>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="state" | type Lwt.state >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.state p>> evaluates to the current state of promise <<span class="odocwiki_inlinecode"|p>>~:


* ~If <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt| fulfilled]] with value <<span class="odocwiki_inlinecode"|v>>~, the result is
      <<span class="odocwiki_inlinecode"|~Lwt~.~Return v>>~.
* ~If <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt| rejected]] with exception <<span class="odocwiki_inlinecode"|exn>>~, the result is
      <<span class="odocwiki_inlinecode"|~Lwt~.~Fail exn>>~.
* ~If <<span class="odocwiki_inlinecode"|p>> is [[ #TYPEt| pending]]~, the result is <<span class="odocwiki_inlinecode"|~Lwt~.~Sleep>>~.

    ~The constructor names are historical holdovers~.
>>


==@@id="2_Deprecated"@@~Deprecated==



===@@id="3_Implicitcallbackarguments"@@~Implicit callback arguments===

<<pre class="ocsforge_color odocwiki_code" id="TYPEkey"|<<span class="ocsforge_color_keyword"|type>> <<span class="odocwiki_type"|'a>> <<span class="odocwiki_name"|key>>>><<div class="odocwiki_info"|~Keys into the implicit callback argument map~, for implicit arguments of type
    <<span class="odocwiki_inlinecode"|~'a option>>~.


    ~The keys are abstract~, but they are basically integers that are all distinct
    from each other~.


    ~See <<a_api | val Lwt.with_value >>~.
>>
<<pre id="VALnew_key" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|new~_key>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="key" | type Lwt.key >>>>>><<div class="odocwiki_info"|~Creates a fresh implicit callback argument key~.


    ~The key is distinct from any other key created by the current process~. ~The
    value <<span class="odocwiki_inlinecode"|~None>> of type <<span class="odocwiki_inlinecode"|~'a option>> is immediately associated with the key~.


    ~See <<a_api | val Lwt.with_value >>~.
>>
<<pre id="VALget" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|get>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="key" | type Lwt.key >> <<span class="ocsforge_color_delimiter"| -> >> 'a option>>>><<div class="odocwiki_info"|~Retrieves the value currently associated with the given implicit callback
    argument key~.


    ~See <<a_api | val Lwt.with_value >>~.
>>
<<pre id="VALwith_value" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|with~_value>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="key" | type Lwt.key >> <<span class="ocsforge_color_delimiter"| -> >> 'a option <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'b>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.with~_value k v f>> sets <<span class="odocwiki_inlinecode"|k>> to <<span class="odocwiki_inlinecode"|v>> in ~Lwt~'s internal implicit callback
    argument map~, then runs <<span class="odocwiki_inlinecode"|f ~(~)>>~, then restores the previous value associated
    with <<span class="odocwiki_inlinecode"|k>>~.


    ~Lwt maintains a single~, global map~, that can be used to “pass” extra
    arguments to callbacks~:



<<code language='ocaml'|let () =
  let k : string Lwt.key = Lwt.new_key () in

  let say_hello () =
    match Lwt.get k with
    | None -> assert false
    | Some s -> Lwt_io.printl s
  in

  Lwt_main.run begin
    Lwt.with_value k (Some "Hello world!") begin fun () ->
      Lwt.bind
        (Lwt_unix.sleep 1.)
        (fun () -> say_hello ())
    end
  end

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



    ~Note that the string <<span class="odocwiki_inlinecode"|~Hello world!>> was passed to <<span class="odocwiki_inlinecode"|say~_hello>> through the
    key <<span class="odocwiki_inlinecode"|k>>~. ~Meanwhile~, the only //explicit// argument of the callback
    <<span class="odocwiki_inlinecode"|say~_hello>> is <<span class="odocwiki_inlinecode"|~(~)>>~.


    ~The way this works is functions like <<a_api | val Lwt.bind >> take a **snapshot** of the
    implicit argument map~. ~Later~, right before the callback is run~, the map is
    //restored// to that snapshot~. ~In other words~, the map has the same state
    inside the callback as it did at the time the callback was registered~.


    ~To be more precise~:


* <<span class="odocwiki_inlinecode"|~Lwt~.with~_value>> associates <<span class="odocwiki_inlinecode"|~Some "~Hello world!">> with <<span class="odocwiki_inlinecode"|k>>~, and runs the
      function passed to it~.
* ~This function contains the <<a_api | val Lwt.bind >>~.
* ~O~Caml~'s eager evaluation means the arguments are evaluated first~. ~In
      particular~, the <<span class="odocwiki_inlinecode"|~Lwt~_unix~.sleep ~1~.>> promise is created~.
* <<a_api | val Lwt.bind >> then attaches the callback in its second argument~, the one
      which calls <<span class="odocwiki_inlinecode"|say~_hello>>~, to that <<span class="odocwiki_inlinecode"|sleep>> promise~.
* <<a_api | val Lwt.bind >> also takes a snapshot of the current state of the implicit
      argument map~, and pairs the callback with that snapshot~.
* ~The callback will not run for another second or so~, when the <<span class="odocwiki_inlinecode"|sleep>>
      promise will be resolved~.
* ~Instead~, <<a_api | val Lwt.bind >> returns its result promise <<span class="odocwiki_inlinecode"|p~_~3>>~. ~This causes
      <<span class="odocwiki_inlinecode"|~Lwt~.with~_value>> to also return <<span class="odocwiki_inlinecode"|p~_~3>>~, first restoring <<span class="odocwiki_inlinecode"|k>> to be
      associated with <<span class="odocwiki_inlinecode"|~None>>~.
* <<a_api | val Lwt_main.run >> gets the pending <<span class="odocwiki_inlinecode"|p~_~3>>~, and blocks the whole process~, with
      <<span class="odocwiki_inlinecode"|k>> associated with <<span class="odocwiki_inlinecode"|~None>>~.
* ~One second later~, the <<span class="odocwiki_inlinecode"|sleep>> ~I~/~O completes~, resolving the <<span class="odocwiki_inlinecode"|sleep>>
      promise~.
* ~This triggers the <<span class="odocwiki_inlinecode"|say~_hello>> callback~. ~Right before the callback is
      called~, the implicit argument map is restored to its snapshot~, so <<span class="odocwiki_inlinecode"|k>> is
      associated with <<span class="odocwiki_inlinecode"|~Some "~Hello world!">>~.
* ~After the callback completes~, ~Lwt again restores <<span class="odocwiki_inlinecode"|k>> to be associated with
      <<span class="odocwiki_inlinecode"|~None>>~.

    ~The ~Lwt functions that take snapshots of the implicit callback argument map
    are exactly those which attach callbacks to promises~: <<a_api | val Lwt.bind >> and its
    variants <<span class="odocwiki_inlinecode"|~>~>~=>> and <<span class="odocwiki_inlinecode"|let~%lwt>>~, <<a_api | val Lwt.map >> and its variant <<span class="odocwiki_inlinecode"|~>~|~=>>~, <<a_api | val Lwt.catch >>
    and its variant <<span class="odocwiki_inlinecode"|try~%lwt>>~, <<a_api | val Lwt.finalize >> and its variant <<span class="odocwiki_inlinecode"|~%lwt~.finally>>~,
    <<a_api | val Lwt.try_bind >>~, <<a_api | val Lwt.on_success >>~, <<a_api | val Lwt.on_failure >>~,
    <<a_api | val Lwt.on_termination >>~, and <<a_api | val Lwt.on_any >>~.


    ~Using this mechanism is discouraged~, because it is non~-syntactic~, and
    because it manipulates hidden state in module <<span class="odocwiki_inlinecode"|~Lwt>>~. ~It is recommended
    instead to pass additional values explicitly in tuples~, or maintain explicit
    associative maps for them~.


    <<span class="odocwiki_inlinecode"|~Lwt~.with~_value>> should only be called in the main thread~, i~.e~. do not call
    it inside <<a_api | val Lwt_preemptive.detach >>~.
>>


===@@id="3_Immediateresolving"@@~Immediate resolving===

<<pre id="VALwakeup" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup r v>> is like <<a_api | val Lwt.wakeup_later >><<span class="odocwiki_inlinecode"| r v>>~, except it guarantees
    that callbacks associated with <<span class="odocwiki_inlinecode"|r>> will be called immediately~, deeper on the
    current stack~.


    ~In contrast~, <<a_api | val Lwt.wakeup_later >> //may// call callbacks immediately~, or may
    queue them for execution on a shallower stack – though still before the next
    time ~Lwt blocks the process on ~I~/~O~.


    ~Using this function is discouraged~, because calling it in a loop can exhaust
    the stack~. ~The loop might be difficult to detect or predict~, due to combined
    mutually~-recursive calls between multiple modules and libraries~.


    ~Also~, trying to use this function to guarantee the timing of callback calls
    for synchronization purposes is discouraged~. ~This synchronization effect is
    obscure to readers~. ~It is better to use explicit promises~, or <<a_api | module Lwt_mutex >>~,
    <<a_api | module Lwt_condition >>~, and~/or <<a_api | module Lwt_mvar >>~.
>>
<<pre id="VALwakeup_exn" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup~_exn>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> exn <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_exn r exn>> is like <<a_api | val Lwt.wakeup_later_exn >><<span class="odocwiki_inlinecode"| r exn>>~, but has
    the same problems as <<a_api | val Lwt.wakeup >>~.
>>
<<pre id="VALwakeup_result" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wakeup~_result>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="result" | type Lwt.result >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wakeup~_result r result>> is like <<a_api | val Lwt.wakeup_later_result >><<span class="odocwiki_inlinecode"| r result>>~,
    but has the same problems as <<a_api | val Lwt.wakeup >>~.
>>


===@@id="3_Helpersforresolving"@@~Helpers for resolving===

<<pre id="VALmake_value" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|make~_value>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="result" | type Lwt.result >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.make~_value v>> is equivalent to
    [[ https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult|
    <<span class="odocwiki_inlinecode"|~Ok v>>]] since ~O~Caml ~4~.~0~3~. ~If you need compatibility with ~O~Caml ~4~.~0~2~, use
    <<span class="odocwiki_inlinecode"|~Result~.~Ok>> and depend on opam package
    [[ https://opam.ocaml.org/packages/result/| <<span class="odocwiki_inlinecode"|result>>]]~.
>>
<<pre id="VALmake_error" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|make~_error>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|exn <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="result" | type Lwt.result >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.make~_error exn>> is equivalent to
    [[ https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult|
    <<span class="odocwiki_inlinecode"|~Error exn>>]] since ~O~Caml ~4~.~0~3~. ~If you need compatibility with ~O~Caml ~4~.~0~2~,
    use <<span class="odocwiki_inlinecode"|~Result~.~Error>> and depend on opam package
    [[ https://opam.ocaml.org/packages/result/| <<span class="odocwiki_inlinecode"|result>>]]~.
>>
<<pre id="VALwaiter_of_wakener" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|waiter~_of~_wakener>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.waiter~_of~_wakener r>> evaluates to the promise associated with resolver
    <<span class="odocwiki_inlinecode"|r>>~.


    ~It is recommended to explicitly keep the reference to the promise
    instead~.
>>


===@@id="3_Linkedlistsofpromises"@@~Linked lists of promises===

<<pre id="VALadd_task_r" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|add~_task~_r>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<a_api text="Lwt_sequence.t" | type Lwt_sequence.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.add~_task~_r sequence>> is equivalent to



<<code language='ocaml'|let p, r = Lwt.task () in
let node = Lwt_sequence.add_r r sequence in
Lwt.on_cancel p (fun () -> Lwt_sequence.remove node);
p
>>



    ~Use of this function is discouraged for two reasons~:


* <<a_api | module Lwt_sequence >> should not be used outside ~Lwt~.
* ~This function only exists because it performs a minor internal
      optimization~, which may be removed~.

>>
<<pre id="VALadd_task_l" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|add~_task~_l>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="u" | type Lwt.u >> <<a_api text="Lwt_sequence.t" | type Lwt_sequence.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~Like <<a_api | val Lwt.add_task_r >>~, but the equivalent code calls <<a_api | val Lwt_sequence.add_l >>
    instead~.
>>


===@@id="3_Yielding"@@~Yielding===

<<pre id="VALpause" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|pause>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<span class="ocsforge_color_delimiter"| -> >> unit <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.pause ~(~)>> creates a pending promise that is fulfilled after ~Lwt
    finishes calling all currently ready callbacks~, i~.e~. it is fulfilled on the
    next “tick~.”


    ~Putting the rest of your computation into a callback of <<span class="odocwiki_inlinecode"|~Lwt~.pause ~(~)>>
    creates a “yield” that gives other callbacks a chance to run first~.


    ~For example~, to break up a long~-running computation~, allowing ~I~/~O to be
    handled between chunks~:



<<code language='ocaml'|let () =
  let rec handle_io () =
    let%lwt () = Lwt_io.printl "Handling I/O" in
    let%lwt () = Lwt_unix.sleep 0.1 in
    handle_io ()
  in

  let rec compute n =
    if n = 0 then
      Lwt.return ()
    else
      let%lwt () =
        if n mod 1_000_000 = 0 then
          Lwt.pause ()
        else
          Lwt.return ()
      in
      compute (n - 1)
  in

  Lwt.async handle_io;
  Lwt_main.run (compute 100_000_000)

(* ocamlfind opt -linkpkg -package lwt_ppx,lwt.unix code.ml && ./a.out *)
>>



  ~If you replace the call to <<span class="odocwiki_inlinecode"|~Lwt~.pause>> by <<span class="odocwiki_inlinecode"|~Lwt~.return>> in the program above~,
  <<span class="odocwiki_inlinecode"|"~Handling ~I~/~O">> is printed only once~. ~With <<span class="odocwiki_inlinecode"|~Lwt~.pause>>~, it is printed several
  times~, depending on the speed of your machine~.


  ~An alternative way to handle long~-running computations is to detach them to
  preemptive threads using <<a_api | module Lwt_preemptive >>~.
>>


===@@id="3_Functionlifters"@@~Function lifters===

<<pre id="VALwrap" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>unit <<span class="ocsforge_color_delimiter"| -> >> 'a<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.wrap f>> applies <<span class="odocwiki_inlinecode"|f ~(~)>>~. ~If <<span class="odocwiki_inlinecode"|f ~(~)>> returns a value <<span class="odocwiki_inlinecode"|v>>~, <<span class="odocwiki_inlinecode"|~Lwt~.wrap>>
    returns <<a_api | val Lwt.return >><<span class="odocwiki_inlinecode"| v>>~. ~If <<span class="odocwiki_inlinecode"|f ~(~)>> raises an exception exn~, <<span class="odocwiki_inlinecode"|~Lwt~.wrap>>
    returns <<a_api | val Lwt.fail >><<span class="odocwiki_inlinecode"| exn>>~.
>>
<<pre id="VALwrap1" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~1>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap2" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~2>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap3" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~3>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap4" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~4>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap5" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~5>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|\\  <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >>\\  'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap6" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~6>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|\\  <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f <<span class="ocsforge_color_delimiter"| -> >> 'g<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >>\\  'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f <<span class="ocsforge_color_delimiter"| -> >> 'g <<a_api text="t" | type Lwt.t >>>>>><<pre id="VALwrap7" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|wrap~7>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|\\  <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f <<span class="ocsforge_color_delimiter"| -> >> 'g <<span class="ocsforge_color_delimiter"| -> >> 'h<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >>\\  'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<span class="ocsforge_color_delimiter"| -> >> 'c <<span class="ocsforge_color_delimiter"| -> >> 'd <<span class="ocsforge_color_delimiter"| -> >> 'e <<span class="ocsforge_color_delimiter"| -> >> 'f <<span class="ocsforge_color_delimiter"| -> >> 'g <<span class="ocsforge_color_delimiter"| -> >> 'h <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~As a “prototype~,” <<span class="odocwiki_inlinecode"|~Lwt~_wrap~1 f>> creates a promise~-valued function <<span class="odocwiki_inlinecode"|g>>~:



<<code language='ocaml'|let g v =
  try
    let v' = f v in
    Lwt.return v'
  with exn ->
    Lwt.fail exn
>>



    ~The remainder of the functions work analogously – they just work on <<span class="odocwiki_inlinecode"|f>> with
    larger numbers of arguments~.


    ~Note that there is an important difference to <<a_api | val Lwt.wrap >>~. ~These functions
    don~'t run <<span class="odocwiki_inlinecode"|f>>~, nor create the final promise~, immediately~. ~In contrast~,
    <<a_api | val Lwt.wrap >> runs its argument <<span class="odocwiki_inlinecode"|f>> eagerly~.


    ~To get a suspended function instead of the eager execution of <<a_api | val Lwt.wrap >>~,
    use <<span class="odocwiki_inlinecode"|~Lwt~.wrap~1>>~.
>>


===@@id="3_Trivialpromises"@@~Trivial promises===

<<pre id="VALreturn_some" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_some>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<span class="ocsforge_color_delimiter"| -> >> 'a option <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~Counterpart to <<a_api | val Lwt.return_none >>~. ~However~, unlike <<a_api | val Lwt.return_none >>~, this
    function performs no [[ #VALreturn_unit| optimization]]~. ~This is because it
    takes an argument~, so it cannot be evaluated at initialization time~, at
    which time the argument is not yet available~.
>>
<<pre id="VALreturn_ok" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_ok>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a, 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_uid"|Result>><<span class="ocsforge_color_delimiter"| . >><<span class="ocsforge_color_lid"|result>> <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~Like <<a_api | val Lwt.return_some >>~, this function performs no optimization~.
**Since** Lwt 2.6.0\\
>>
<<pre id="VALreturn_error" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|return~_error>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'e <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a, 'e<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_uid"|Result>><<span class="ocsforge_color_delimiter"| . >><<span class="ocsforge_color_lid"|result>> <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~Like <<a_api | val Lwt.return_some >>~, this function performs no optimization~.
**Since** Lwt 2.6.0\\
>>
<<pre id="VALfail_with" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|fail~_with>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|string <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.fail~_with s>> is an abbreviation for



<<code language='ocaml'|Lwt.fail (Pervasives.Failure s)
>>

>>
<<pre id="VALfail_invalid_arg" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|fail~_invalid~_arg>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|string <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.invalid~_arg s>> is an abbreviation for



<<code language='ocaml'|Lwt.fail (Pervasives.Invalid_argument s)
>>

>>


===@@id="3_Unscopedinfixoperators"@@~Unscoped infix operators===

<<pre id="VAL(>>=)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~>~>~=~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<pre id="VAL(>|=)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~>~|~=~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> <<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<pre id="VAL(<?>)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~<~?~>~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >>>>>><<pre id="VAL(<&>)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~<~&~>~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|unit <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> unit <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> unit <<a_api text="t" | type Lwt.t >>>>>><<pre id="VAL(=<<)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~=~<~<~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >><<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<pre id="VAL(=|<)" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|~(~=~|~<~)>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|<<span class="ocsforge_color_delimiter"| ( >>'a <<span class="ocsforge_color_delimiter"| -> >> 'b<<span class="ocsforge_color_delimiter"| ) >> <<span class="ocsforge_color_delimiter"| -> >> 'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> 'b <<a_api text="t" | type Lwt.t >>>>>><<div class="odocwiki_info"|~Use the operators in module [[ #MODULEInfix| <<span class="odocwiki_inlinecode"|~Lwt~.~Infix>>]] instead~. ~Using
    these instances of the operators directly requires opening module <<span class="odocwiki_inlinecode"|~Lwt>>~,
    which brings an excessive number of other names into scope~.
>>


===@@id="3_Miscellaneous"@@~Miscellaneous===

<<pre id="VALis_sleeping" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|is~_sleeping>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> bool>>>><<div class="odocwiki_info"|<<span class="odocwiki_inlinecode"|~Lwt~.is~_sleeping p>> is equivalent to <<a_api | val Lwt.state >><<span class="odocwiki_inlinecode"| p ~= ~Lwt~.~Sleep>>~.
>>
<<pre id="VALignore_result" class="ocsforge_color odocwiki_code"|<<span class="ocsforge_color_keyword"|val>> <<span class="odocwiki_name"|ignore~_result>> <<span class="ocsforge_color_delimiter"|~:>> <<span class="odocwiki_type"|'a <<a_api text="t" | type Lwt.t >> <<span class="ocsforge_color_delimiter"| -> >> unit>>>><<div class="odocwiki_info"|~An obsolete variant of <<a_api | val Lwt.async >>~.


    <<span class="odocwiki_inlinecode"|~Lwt~.ignore~_result p>> behaves as follows~:


* ~If <<span class="odocwiki_inlinecode"|p>> is already fulfilled~, <<span class="odocwiki_inlinecode"|~Lwt~.ignore~_result p>> does nothing~.
* ~If <<span class="odocwiki_inlinecode"|p>> is already rejected with <<span class="odocwiki_inlinecode"|exn>>~, <<span class="odocwiki_inlinecode"|~Lwt~.ignore~_result p>> raises <<span class="odocwiki_inlinecode"|exn>>
      immedaitely~.
* ~If <<span class="odocwiki_inlinecode"|p>> is pending~, <<span class="odocwiki_inlinecode"|~Lwt~.ignore~_result p>> does nothing~, but if <<span class="odocwiki_inlinecode"|p>> becomes
      rejected later~, the exception is passed to <<span class="odocwiki_inlinecode"|!>><<a_api | val Lwt.async_exception_hook >>~.

    ~Use of this function is discouraged for two reasons~:


* ~The behavior is different depending on whether <<span class="odocwiki_inlinecode"|p>> is rejected now or
      later~.
* ~The name is misleading~, and has led to users thinking this function is
      analogous to <<span class="odocwiki_inlinecode"|~Pervasives~.ignore>>~, i~.e~. that it waits for <<span class="odocwiki_inlinecode"|p>> to become
      resolved~, completing any associated side effects along the way~. ~In fact~,
      the function that does //that// is ordinary <<a_api | val Lwt.bind >>~.

>>
