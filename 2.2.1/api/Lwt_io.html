<html><head><title>Module Lwt_io </title><meta charset="utf8"/><link rel="stylesheet" href="https://ocsigen.org/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="text/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Lwt</p><div class="mainmenu"><p class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></p><p class="mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p class="mainmenu-current"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="/img/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-project"><a href=".././../../html_of_wiki/" class="ocsimore_phrasing_link">html_of_wiki</a>
</li><li class="drawermainmenu-project"><a href=".././../../deriving/" class="ocsimore_phrasing_link">deriving</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsimore/" class="ocsimore_phrasing_link">Ocsimore (<em>deprecated</em>)</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../contributing" class="ocsimore_phrasing_link">Contributing</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href=".././../../install" class="ocsimore_phrasing_link">Installation</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h1>Lwt - API Reference</h1><h2>Core library</h2><h3><a href=".././api/Lwt" class="ocsimore_phrasing_link">Lwt</a></h3><h3><a href=".././api/Lwt_condition" class="ocsimore_phrasing_link">Lwt_condition</a></h3><h3><a href=".././api/Lwt_list" class="ocsimore_phrasing_link">Lwt_list</a></h3><h3><a href=".././api/Lwt_mutex" class="ocsimore_phrasing_link">Lwt_mutex</a></h3><h3><a href=".././api/Lwt_mvar" class="ocsimore_phrasing_link">Lwt_mvar</a></h3><h3><a href=".././api/Lwt_pool" class="ocsimore_phrasing_link">Lwt_pool</a></h3><h3><a href=".././api/Lwt_sequence" class="ocsimore_phrasing_link">Lwt_sequence</a></h3><h3><a href=".././api/Lwt_stream" class="ocsimore_phrasing_link">Lwt_stream</a></h3><h3><a href=".././api/Lwt_switch" class="ocsimore_phrasing_link">Lwt_switch</a></h3><h2>Unix bindings</h2><h3><a href=".././api/Lwt_daemon" class="ocsimore_phrasing_link">Lwt_daemon</a></h3><h3><a href=".././api/Lwt_gc" class="ocsimore_phrasing_link">Lwt_gc</a></h3><h3><a href=".././api/Lwt_io" class="ocsimore_phrasing_link">Lwt_io</a></h3><h3><a href=".././api/Lwt_log" class="ocsimore_phrasing_link">Lwt_log</a></h3><h3><a href=".././api/Lwt_main" class="ocsimore_phrasing_link">Lwt_main</a></h3><h3><a href=".././api/Lwt_process" class="ocsimore_phrasing_link">Lwt_process</a></h3><h3><a href=".././api/Lwt_throttle" class="ocsimore_phrasing_link">Lwt_throttle</a></h3><h3><a href=".././api/Lwt_timeout" class="ocsimore_phrasing_link">Lwt_timeout</a></h3><h3><a href=".././api/Lwt_unix" class="ocsimore_phrasing_link">Lwt_unix</a></h3><h3><a href=".././api/Lwt_bytes" class="ocsimore_phrasing_link">Lwt_bytes</a></h3><h2>Reactive programming helpers</h2><h3><a href=".././api/Lwt_event" class="ocsimore_phrasing_link">Lwt_event</a></h3><h3><a href=".././api/Lwt_signal" class="ocsimore_phrasing_link">Lwt_signal</a></h3><h2>Syntax extensions</h2><h3><a href=".././api/Pa_lwt" class="ocsimore_phrasing_link">Pa_lwt</a></h3><h3><a href=".././api/Pa_lwt_log" class="ocsimore_phrasing_link">Pa_lwt_log</a></h3><h2>Terminal manipulation</h2><h3><a href=".././api/Lwt_read_line" class="ocsimore_phrasing_link">Lwt_read_line</a></h3><h3><a href=".././api/Lwt_term" class="ocsimore_phrasing_link">Lwt_term</a></h3><h3><a href=".././api/Lwt_text" class="ocsimore_phrasing_link">Lwt_text</a></h3><h2>Miscellaneous</h2><h3><a href=".././api/Lwt_glib" class="ocsimore_phrasing_link">Lwt_glib</a></h3><h3><a href=".././api/Lwt_lib" class="ocsimore_phrasing_link">Lwt_lib</a></h3><h3><a href=".././api/Lwt_preemptive" class="ocsimore_phrasing_link">Lwt_preemptive</a></h3><h3><a href=".././api/Lwt_ssl" class="ocsimore_phrasing_link">Lwt_ssl</a></h3><h2>Index</h2></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../1.0.0/api/Lwt_io">1.0.0</option><option value=".././../1.1.0/api/Lwt_io">1.1.0</option><option value=".././../2.0.0/api/Lwt_io">2.0.0</option><option value=".././../2.1.0/api/Lwt_io">2.1.0</option><option value=".././../2.1.1/api/Lwt_io">2.1.1</option><option value=".././../2.2.0/api/Lwt_io">2.2.0</option><option value=".././../2.2.1/api/Lwt_io" selected="selected">2.2.1</option><option value=".././../2.3.0/api/Lwt_io">2.3.0</option><option value=".././../2.3.1/api/Lwt_io">2.3.1</option><option value=".././../2.3.2/api/Lwt_io">2.3.2</option><option value=".././../2.4.0/api/Lwt_io">2.4.0</option><option value=".././../2.4.1/api/Lwt_io">2.4.1</option><option value=".././../2.4.2/api/Lwt_io">2.4.2</option><option value=".././../2.4.3/api/Lwt_io">2.4.3</option><option value=".././../2.4.7/api/Lwt_io">2.4.7</option><option value=".././../2.4.8/api/Lwt_io">2.4.8</option><option value=".././../2.5.0/api/Lwt_io">2.5.0</option><option value=".././../2.5.1/api/Lwt_io">2.5.1</option><option value=".././../2.5.2/api/Lwt_io">2.5.2</option><option value=".././../2.6.0/api/Lwt_io">2.6.0</option><option value=".././../2.7.0/api/Lwt_io">2.7.0</option><option value=".././../2.7.1/api/Lwt_io">2.7.1</option><option value=".././../3.0.0/api/Lwt_io">3.0.0</option><option value=".././../3.1.0/api/Lwt_io">3.1.0</option><option value=".././../3.2.1/api/Lwt_io">3.2.1</option><option value=".././../3.3.0/api/Lwt_io">3.3.0</option><option value=".././../4.0.0/api/Lwt_io">4.0.0</option><option value=".././../4.0.1/api/Lwt_io">4.0.1</option><option value=".././../4.1.0/api/Lwt_io">4.1.0</option><option value=".././../dev/api/Lwt_io">dev</option></select><nav class="how-doctree"><h1>Lwt - API Reference</h1><h2>Core library</h2><h3><a href=".././api/Lwt" class="ocsimore_phrasing_link">Lwt</a></h3><h3><a href=".././api/Lwt_condition" class="ocsimore_phrasing_link">Lwt_condition</a></h3><h3><a href=".././api/Lwt_list" class="ocsimore_phrasing_link">Lwt_list</a></h3><h3><a href=".././api/Lwt_mutex" class="ocsimore_phrasing_link">Lwt_mutex</a></h3><h3><a href=".././api/Lwt_mvar" class="ocsimore_phrasing_link">Lwt_mvar</a></h3><h3><a href=".././api/Lwt_pool" class="ocsimore_phrasing_link">Lwt_pool</a></h3><h3><a href=".././api/Lwt_sequence" class="ocsimore_phrasing_link">Lwt_sequence</a></h3><h3><a href=".././api/Lwt_stream" class="ocsimore_phrasing_link">Lwt_stream</a></h3><h3><a href=".././api/Lwt_switch" class="ocsimore_phrasing_link">Lwt_switch</a></h3><h2>Unix bindings</h2><h3><a href=".././api/Lwt_daemon" class="ocsimore_phrasing_link">Lwt_daemon</a></h3><h3><a href=".././api/Lwt_gc" class="ocsimore_phrasing_link">Lwt_gc</a></h3><h3><a href=".././api/Lwt_io" class="ocsimore_phrasing_link">Lwt_io</a></h3><h3><a href=".././api/Lwt_log" class="ocsimore_phrasing_link">Lwt_log</a></h3><h3><a href=".././api/Lwt_main" class="ocsimore_phrasing_link">Lwt_main</a></h3><h3><a href=".././api/Lwt_process" class="ocsimore_phrasing_link">Lwt_process</a></h3><h3><a href=".././api/Lwt_throttle" class="ocsimore_phrasing_link">Lwt_throttle</a></h3><h3><a href=".././api/Lwt_timeout" class="ocsimore_phrasing_link">Lwt_timeout</a></h3><h3><a href=".././api/Lwt_unix" class="ocsimore_phrasing_link">Lwt_unix</a></h3><h3><a href=".././api/Lwt_bytes" class="ocsimore_phrasing_link">Lwt_bytes</a></h3><h2>Reactive programming helpers</h2><h3><a href=".././api/Lwt_event" class="ocsimore_phrasing_link">Lwt_event</a></h3><h3><a href=".././api/Lwt_signal" class="ocsimore_phrasing_link">Lwt_signal</a></h3><h2>Syntax extensions</h2><h3><a href=".././api/Pa_lwt" class="ocsimore_phrasing_link">Pa_lwt</a></h3><h3><a href=".././api/Pa_lwt_log" class="ocsimore_phrasing_link">Pa_lwt_log</a></h3><h2>Terminal manipulation</h2><h3><a href=".././api/Lwt_read_line" class="ocsimore_phrasing_link">Lwt_read_line</a></h3><h3><a href=".././api/Lwt_term" class="ocsimore_phrasing_link">Lwt_term</a></h3><h3><a href=".././api/Lwt_text" class="ocsimore_phrasing_link">Lwt_text</a></h3><h2>Miscellaneous</h2><h3><a href=".././api/Lwt_glib" class="ocsimore_phrasing_link">Lwt_glib</a></h3><h3><a href=".././api/Lwt_lib" class="ocsimore_phrasing_link">Lwt_lib</a></h3><h3><a href=".././api/Lwt_preemptive" class="ocsimore_phrasing_link">Lwt_preemptive</a></h3><h3><a href=".././api/Lwt_ssl" class="ocsimore_phrasing_link">Lwt_ssl</a></h3><h2>Index</h2></nav></nav><article class="rightcol"><h1>Module <span><a href=".././api/Lwt_io">Lwt_io</a></span> </h1><div class="code"><p><span class="keyword">module</span> Lwt_io: <span class="code">sig</span><span><a href=".././api/Lwt_io">..</a></span><span class="code">end</span></p></div><p>Buffered byte channels<br/>
</p><hr/><p><br/>
A <strong>channel</strong> is a high-level object for performing IOs. It allow
to read/write things from/to the outside worlds in an efficient
way, by minimising the number of system calls.<br/>
</p><p>An <strong>output channel</strong> is a channel that can be used to send data
and an <strong>input channel</strong> is a channel that can used to receive
data.<br/>
</p><p>If you are familiar with buffered channels you may be familiar too
with the <strong>flush</strong> operation. Note that byte channles of this
modules are automatically flushed when there is nothing else to do
(i.e. before the program goes into idle), so this means that you
no longer have to write:<br/>
</p><p>
</p><pre>      eprintf &quot;log message\n&quot;;
      flush stderr;
    
</pre><p><br/>
</p><p>to have you messages displayed.<br/>
</p><p>Note about errors: input functions of this module raise
<span class="code">End_of_file</span> when the end-of-file is reached (i.e. when the read
function returns <span class="code">0</span>). Other exceptions are ones caused by the
backend read/write functions, such as <span class="code">Unix.Unix_error</span>.<br/>
</p><div class="code" id="EXCEPTIONChannel_closed"><p><span class="keyword">exception</span> Channel_closed <span class="keyword">of</span> <span class="code type">string</span></p></div><div class="info"><p>Exception raised when a channel is closed. The parameter is a
description of the channel.<br/></p></div><p><br/>
</p><h6 id="6_Types">Types <a class="backref" href="#6_Types">&#182;</a></h6><p><br/>
</p><div class="code" id="TYPEchannel"><p><span class="keyword">type</span> <span class="code type">'a</span> channel</p></div><div class="info"><p>Type of buffered byte channels<br/></p></div><div class="code" id="TYPEinput"><p><span class="keyword">type</span> input</p></div><div class="info"><p>Input mode<br/></p></div><div class="code" id="TYPEoutput"><p><span class="keyword">type</span> output</p></div><div class="info"><p>Output mode<br/></p></div><div class="code" id="TYPEmode"><p><span class="keyword">type</span> <span class="code type">'a</span> mode = private 
</p><table class="typetable"><tr><td class="lefttop"><span class="keyword"><span class="teletype">|</span></span></td><td class="lefttop"><span class="constructor">Input</span></td></tr><tr><td class="lefttop"><span class="keyword"><span class="teletype">|</span></span></td><td class="lefttop"><span class="constructor">Output</span></td></tr></table></div><div class="info"><p>Channel mode<br/></p></div><div class="code" id="VALinput"><p><span class="keyword">val</span> input : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput">input</a></span> <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span></span></p></div><div class="info"><p><span class="code">input</span> input mode representation<br/></p></div><div class="code" id="VALoutput"><p><span class="keyword">val</span> output : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput">output</a></span> <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span></span></p></div><div class="info"><p><span class="code">output</span> output mode representation<br/></p></div><div class="code" id="TYPEinput_channel"><p><span class="keyword">type</span> input_channel = <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput">input</a></span> <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p>Type of input channels<br/></p></div><div class="code" id="TYPEoutput_channel"><p><span class="keyword">type</span> output_channel = <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput">output</a></span> <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p>Type of output channels<br/></p></div><div class="code" id="VALmode"><p><span class="keyword">val</span> mode : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; 'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span></span></p></div><div class="info"><p><span class="code">mode ch</span> returns the mode of a channel<br/></p></div><p><br/>
</p><h6 id="6_Wellknowninstances">Well-known instances <a class="backref" href="#6_Wellknowninstances">&#182;</a></h6><p><br/>
</p><div class="code" id="VALstdin"><p><span class="keyword">val</span> stdin : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span></span></p></div><div class="info"><p>The standard input, it reads data from <span><a href=".././api/Lwt_unix#VALstdin">Lwt_unix.stdin</a></span><br/></p></div><div class="code" id="VALstdout"><p><span class="keyword">val</span> stdout : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span></span></p></div><div class="info"><p>The standard output, it writes data to <span><a href=".././api/Lwt_unix#VALstdout">Lwt_unix.stdout</a></span><br/></p></div><div class="code" id="VALstderr"><p><span class="keyword">val</span> stderr : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span></span></p></div><div class="info"><p>The standard output for error messages, it writes data to
<span><a href=".././api/Lwt_unix#VALstderr">Lwt_unix.stderr</a></span><br/></p></div><div class="code" id="VALzero"><p><span class="keyword">val</span> zero : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span></span></p></div><div class="info"><p>Inputs which returns always <span class="code">'\x00'</span><br/></p></div><div class="code" id="VALnull"><p><span class="keyword">val</span> null : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span></span></p></div><div class="info"><p>Output which drops everything<br/></p></div><p><br/>
</p><h6 id="6_Channelscreationmanipulation">Channels creation/manipulation <a class="backref" href="#6_Channelscreationmanipulation">&#182;</a></h6><p><br/>
</p><div class="code" id="VALpipe"><p><span class="keyword">val</span> pipe : <span class="code type">?buffer_size:int -&gt; unit -&gt; <span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> * <span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span></span></p></div><div class="info"><p><span class="code">pipe ?buffer_size ()</span> creates a pipe using <span><a href=".././api/Lwt_unix#VALpipe">Lwt_unix.pipe</a></span> and
makes two channels from the two returned file descriptors<br/></p></div><div class="code" id="VALmake"><p><span class="keyword">val</span> make : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?close:(unit -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt;<br/><span class="teletype">   </span>  ?seek:(int64 -&gt; Unix.seek_command -&gt; int64 <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt;<br/><span class="teletype">   </span>  mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt;<br/><span class="teletype">   </span>  (<span><a href=".././api/Lwt_bytes#TYPEt">Lwt_bytes.t</a></span> -&gt; int -&gt; int -&gt; int <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p><span class="code">make ?buffer_size ?close ~mode perform_io</span> is the
main function for creating new channels.<br/></p></div><div class="param_info"><p><span class="code code">buffer_size</span> : size of the internal buffer. It must be
between 16 and <span class="code">Sys.max_string_length</span></p></div><div class="param_info"><p><span class="code code">close</span> : close function of the channel. It defaults to
<span class="code">Lwt.return</span></p></div><div class="param_info"><p><span class="code code">seek</span> : same meaning as <span class="code">Unix.lseek</span></p></div><div class="param_info"><p><span class="code code">mode</span> : either <span><a href=".././api/Lwt_io#VALinput">Lwt_io.input</a></span> or <span><a href=".././api/Lwt_io#VALoutput">Lwt_io.output</a></span></p></div><div class="code" id="VALof_bytes"><p><span class="keyword">val</span> of_bytes : <span class="code type">mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt; <span><a href=".././api/Lwt_bytes#TYPEt">Lwt_bytes.t</a></span> -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p>Create a channel from a byte array. Reading/writing is done
directly on the provided array.<br/></p></div><div class="code" id="VALof_fd"><p><span class="keyword">val</span> of_fd : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?close:(unit -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt;<br/><span class="teletype">   </span>  mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt; <span><a href=".././api/Lwt_unix#TYPEfile_descr">Lwt_unix.file_descr</a></span> -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p><span class="code">of_fd ?buffer_size ?close ~mode fd</span> creates a channel from a
file descriptor.<br/></p></div><div class="param_info"><p><span class="code code">close</span> : defaults to closing the file descriptor.</p></div><div class="code" id="VALof_unix_fd"><p><span class="keyword">val</span> of_unix_fd : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?close:(unit -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt;<br/><span class="teletype">   </span>  mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt; Unix.file_descr -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span></span></p></div><div class="info"><p><span class="code">of_unix_fd ?buffer_size ?close ~mode fd</span> is a short-hand for:<br/>
</p><p><span class="code">of_fd ?buffer_size ?close (Lwt_unix.of_unix_file_descr fd)</span><br/></p></div><div class="code" id="VALclose"><p><span class="keyword">val</span> close : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">close ch</span> closes the given channel. If <span class="code">ch</span> is an output
channel, it performs all pending actions, flush it and close
it. If <span class="code">ch</span> is an input channel, it just close it immediatly.<br/>
</p><p><span class="code">close</span> returns the result of the close function of the
channel. Multiple calls to <span class="code">close</span> will return exactly the same
value.<br/>
</p><p>Note: you cannot use <span class="code">close</span> on channel obtained with an
<span><a href=".././api/Lwt_io#VALatomic">Lwt_io.atomic</a></span>.<br/></p></div><div class="code" id="VALabort"><p><span class="keyword">val</span> abort : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">abort ch</span> abort current operations and close the channel
immediatly.<br/></p></div><div class="code" id="VALatomic"><p><span class="keyword">val</span> atomic : <span class="code type">('a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">atomic f</span> transforms a sequence of io operations into one
single atomic io operation.<br/>
</p><p>Note:* the channel passed to <span class="code">f</span> is invalid after <span class="code">f</span> terminates
</p><ul><li> <span class="code">atomic</span> can be called inside another <span class="code">atomic</span>
</li></ul><p><br/></p></div><div class="code" id="VALfile_length"><p><span class="keyword">val</span> file_length : <span class="code type">string -&gt; int64 <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p>Returns the length of a file<br/></p></div><div class="code" id="VALbuffered"><p><span class="keyword">val</span> buffered : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int</span></p></div><div class="info"><p><span class="code">buffered oc</span> returns the number of bytes in the buffer<br/></p></div><div class="code" id="VALflush"><p><span class="keyword">val</span> flush : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">flush oc</span> performs all pending writes on <span class="code">oc</span><br/></p></div><div class="code" id="VALbuffer_size"><p><span class="keyword">val</span> buffer_size : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int</span></p></div><div class="info"><p>Returns the size of the internal buffer.<br/></p></div><div class="code" id="VALresize_buffer"><p><span class="keyword">val</span> resize_buffer : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p>Resize the internal buffer to the given size<br/></p></div><div class="code" id="VALis_busy"><p><span class="keyword">val</span> is_busy : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; bool</span></p></div><div class="info"><p><span class="code">is_busy channel</span> returns whether the given channel is currently
busy. A channel is busy when there is at least one job using it
that has not yet terminated.<br/></p></div><p><br/>
</p><h6 id="6_Randomaccess">Random access <a class="backref" href="#6_Randomaccess">&#182;</a></h6><p><br/>
</p><div class="code" id="VALposition"><p><span class="keyword">val</span> position : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int64</span></p></div><div class="info"><p><span class="code">position ch</span> Returns the current position in the channel.<br/></p></div><div class="code" id="VALset_position"><p><span class="keyword">val</span> set_position : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int64 -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">set_position ch pos</span> Sets the position in the output channel. This
does not work if the channel do not support random access.<br/></p></div><div class="code" id="VALlength"><p><span class="keyword">val</span> length : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int64 <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p>Returns the length of the channel in bytes<br/></p></div><p><br/>
</p><h6 id="6_Reading">Reading <a class="backref" href="#6_Reading">&#182;</a></h6><p><br/>
<br/>
Note: except for functions dealing with streams (<span><a href=".././api/Lwt_io#VALread_chars">Lwt_io.read_chars</a></span> and
<span><a href=".././api/Lwt_io#VALread_lines">Lwt_io.read_lines</a></span>) all functions are <strong>atomic</strong>.<br/>
</p><div class="code" id="VALread_char"><p><span class="keyword">val</span> read_char : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; char <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read_char ic</span> reads the next character of <span class="code">ic</span>.<br/>
<strong>Raises</strong> <span class="teletype">End_of_file</span> if the end of the file is reached<br/></p></div><div class="code" id="VALread_char_opt"><p><span class="keyword">val</span> read_char_opt : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; char option <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p>Same as <span class="code">read_byte</span> but does not raises <span class="code">End_of_file</span> on end of
input<br/></p></div><div class="code" id="VALread_chars"><p><span class="keyword">val</span> read_chars : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; char <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span></span></p></div><div class="info"><p><span class="code">read_chars ic</span> returns a stream holding all characters of
<span class="code">ic</span><br/></p></div><div class="code" id="VALread_line"><p><span class="keyword">val</span> read_line : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read_line ic</span> reads one complete line from <span class="code">ic</span> and returns it
without the end of line. End of line is either <span class="code">&quot;\n&quot;</span> or
<span class="code">&quot;\r\n&quot;</span>.<br/>
</p><p>If the end of line is reached before reading any character,
<span class="code">End_of_file</span> is raised. If it is reached before reading an end
of line but characters have already been read, they are
returned.<br/></p></div><div class="code" id="VALread_line_opt"><p><span class="keyword">val</span> read_line_opt : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string option <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p>Same as <span><a href=".././api/Lwt_io#VALread_line">Lwt_io.read_line</a></span> but do not raise <span class="code">End_of_file</span> on end of
input.<br/></p></div><div class="code" id="VALread_lines"><p><span class="keyword">val</span> read_lines : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span></span></p></div><div class="info"><p><span class="code">read_lines ic</span> returns a stream holding all lines of <span class="code">ic</span><br/></p></div><div class="code" id="VALread"><p><span class="keyword">val</span> read : <span class="code type">?count:int -&gt; <span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read ?count ic</span> reads at most <span class="code">len</span> characters from <span class="code">ic</span>. It
returns <span class="code">&quot;&quot;</span> if the end of input is reached. If <span class="code">count</span> is not
specified, it reads all bytes until the end of input.<br/></p></div><div class="code" id="VALread_into"><p><span class="keyword">val</span> read_into : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string -&gt; int -&gt; int -&gt; int <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read_into ic buffer offset length</span> reads up to <span class="code">length</span> bytes,
stores them in <span class="code">buffer</span> at offset <span class="code">offset</span>, and returns the
number of bytes read.<br/>
</p><p>Note: <span class="code">read_into</span> does not raise <span class="code">End_of_file</span>, it returns a
length of <span class="code">0</span> instead.<br/></p></div><div class="code" id="VALread_into_exactly"><p><span class="keyword">val</span> read_into_exactly : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; string -&gt; int -&gt; int -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read_into_exactly ic buffer offset length</span> reads exactly
<span class="code">length</span> bytes and stores them in <span class="code">buffer</span> at offset <span class="code">offset</span>.<br/>
<strong>Raises</strong> <span class="teletype">End_of_file</span> on end of input<br/></p></div><div class="code" id="VALread_value"><p><span class="keyword">val</span> read_value : <span class="code type"><span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> -&gt; 'a <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">read_value ic</span> reads a marshaled value from <span class="code">ic</span><br/></p></div><p><br/>
</p><h6 id="6_Writing">Writing <a class="backref" href="#6_Writing">&#182;</a></h6><p><br/>
<br/>
Note: as for reading functions, all functions except
<span><a href=".././api/Lwt_io#VALwrite_chars">Lwt_io.write_chars</a></span> and <span><a href=".././api/Lwt_io#VALwrite_lines">Lwt_io.write_lines</a></span> are <strong>atomic</strong>.<br/>
</p><p>For example if you use <span><a href=".././api/Lwt_io#VALwrite_line">Lwt_io.write_line</a></span> in to different threads, the
two operations will be serialized, and lines cannot be mixed.<br/>
</p><div class="code" id="VALwrite_char"><p><span class="keyword">val</span> write_char : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; char -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_char oc char</span> writes <span class="code">char</span> on <span class="code">oc</span><br/></p></div><div class="code" id="VALwrite_chars"><p><span class="keyword">val</span> write_chars : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; char <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_chars oc chars</span> writes all characters of <span class="code">chars</span> on
<span class="code">oc</span><br/></p></div><div class="code" id="VALwrite"><p><span class="keyword">val</span> write : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write oc str</span> writes all characters of <span class="code">str</span> on <span class="code">oc</span><br/></p></div><div class="code" id="VALwrite_line"><p><span class="keyword">val</span> write_line : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_line oc str</span> writes <span class="code">str</span> on <span class="code">oc</span> followed by a
new-line.<br/></p></div><div class="code" id="VALwrite_lines"><p><span class="keyword">val</span> write_lines : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_lines oc lines</span> writes all lines of <span class="code">lines</span> to <span class="code">oc</span><br/></p></div><div class="code" id="VALwrite_from"><p><span class="keyword">val</span> write_from : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; int -&gt; int -&gt; int <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_from oc buffer offset length</span> writes up to <span class="code">length</span> bytes
to <span class="code">oc</span>, from <span class="code">buffer</span> at offset <span class="code">offset</span> and returns the number
of bytes actually written<br/></p></div><div class="code" id="VALwrite_from_exactly"><p><span class="keyword">val</span> write_from_exactly : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; int -&gt; int -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_from_exactly oc buffer offset length</span> writes all <span class="code">length</span>
bytes from <span class="code">buffer</span> at offset <span class="code">offset</span> to <span class="code">oc</span><br/></p></div><div class="code" id="VALwrite_value"><p><span class="keyword">val</span> write_value : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; ?flags:Marshal.extern_flags list -&gt; 'a -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">write_value oc ?flags x</span> marshals the value <span class="code">x</span> to <span class="code">oc</span><br/></p></div><p><br/>
</p><h6 id="6_Printing">Printing <a class="backref" href="#6_Printing">&#182;</a></h6><p><br/>
<br/>
These functions are basically helpers. Also you may prefer the
using the name <span><a href=".././api/Lwt_io#VALprintl">Lwt_io.printl</a></span> rather than <span><a href=".././api/Lwt_io#VALwrite_line">Lwt_io.write_line</a></span> because it is
shorter.<br/>
</p><p>The general name of a printing function is <span class="code">&lt;prefix&gt;print&lt;suffixes&gt;</span>.<br/>
</p><p>Where <span class="code">&lt;prefix&gt;</span> is one of:* <span class="code">'f'</span>, which means that the function takes as argument a channel
</p><ul><li> nothing, which means that the function prints on <span><a href=".././api/Lwt_io#VALstdout">Lwt_io.stdout</a></span>
</li><li> <span class="code">'e'</span>, which means that the function prints on <span><a href=".././api/Lwt_io#VALstderr">Lwt_io.stderr</a></span>
</li></ul><p>and <span class="code">&lt;suffixes&gt;</span> is a combination of:* <span class="code">'l'</span> which means that a new-line character is printed after the message
</p><ul><li> <span class="code">'f'</span> which means that the function takes as argument a <strong>format</strong> instead
of a string
</li></ul><p><br/>
</p><div class="code" id="VALfprint"><p><span class="keyword">val</span> fprint : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALfprintl"><p><span class="keyword">val</span> fprintl : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALfprintf"><p><span class="keyword">val</span> fprintf : <span class="code type"><br/><span class="teletype">   </span><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt;<br/><span class="teletype">   </span>  ('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><div class="code" id="VALfprintlf"><p><span class="keyword">val</span> fprintlf : <span class="code type"><br/><span class="teletype">   </span><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt;<br/><span class="teletype">   </span>  ('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><div class="code" id="VALprint"><p><span class="keyword">val</span> print : <span class="code type">string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALprintl"><p><span class="keyword">val</span> printl : <span class="code type">string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALprintf"><p><span class="keyword">val</span> printf : <span class="code type">('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><div class="code" id="VALprintlf"><p><span class="keyword">val</span> printlf : <span class="code type">('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><div class="code" id="VALeprint"><p><span class="keyword">val</span> eprint : <span class="code type">string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALeprintl"><p><span class="keyword">val</span> eprintl : <span class="code type">string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="code" id="VALeprintf"><p><span class="keyword">val</span> eprintf : <span class="code type">('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><div class="code" id="VALeprintlf"><p><span class="keyword">val</span> eprintlf : <span class="code type">('a, unit, string, unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) Pervasives.format4 -&gt; 'a</span></p></div><p><br/>
</p><h6 id="6_Utilities">Utilities <a class="backref" href="#6_Utilities">&#182;</a></h6><p><br/>
</p><div class="code" id="VALhexdump_stream"><p><span class="keyword">val</span> hexdump_stream : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; char <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">hexdump_stream oc byte_stream</span> produces the same output as the
command <span class="code">hexdump -C</span>.<br/></p></div><div class="code" id="VALhexdump"><p><span class="keyword">val</span> hexdump : <span class="code type"><span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; string -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</span><br/></p></div><p><br/>
</p><h6 id="6_Fileutilities">File utilities <a class="backref" href="#6_Fileutilities">&#182;</a></h6><p><br/>
</p><div class="code" id="TYPEfile_name"><p><span class="keyword">type</span> file_name = <span class="code type">string</span></p></div><div class="info"><p>Type of file names<br/></p></div><div class="code" id="VALopen_file"><p><span class="keyword">val</span> open_file : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?flags:Unix.open_flag list -&gt;<br/><span class="teletype">   </span>  ?perm:Unix.file_perm -&gt;<br/><span class="teletype">   </span>  mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt; <span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; 'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">open_file ?buffer_size ?flags ?perm ~mode filename</span> open the
file with name <span class="code">filename</span> and returns a channel for
reading/writing it.<br/>
<strong>Raises</strong> <span class="teletype">Unix.Unix_error</span> on error.<br/></p></div><div class="code" id="VALwith_file"><p><span class="keyword">val</span> with_file : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?flags:Unix.open_flag list -&gt;<br/><span class="teletype">   </span>  ?perm:Unix.file_perm -&gt;<br/><span class="teletype">   </span>  mode:'a <span><a href=".././api/Lwt_io#TYPEmode">mode</a></span> -&gt;<br/><span class="teletype">   </span>  <span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; ('a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">with_file ?buffer_size ?flags ?perm ~mode filename f</span> open a
file and passes the channel to <span class="code">f</span>. It is ensured that the
channel is closed when <span class="code">f ch</span> terminates (even if it fails).<br/></p></div><div class="code" id="VALopen_connection"><p><span class="keyword">val</span> open_connection : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  Unix.sockaddr -&gt; (<span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> * <span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span>) <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">open_connection ?buffer_size ~mode addr</span> open a connection to
the given address and returns two channels for using it.<br/>
</p><p>The connection is completly closed when you close both
channels.<br/>
<strong>Raises</strong> <span class="teletype">Unix.Unix_error</span> on error.<br/></p></div><div class="code" id="VALwith_connection"><p><span class="keyword">val</span> with_connection : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  Unix.sockaddr -&gt;<br/><span class="teletype">   </span>  (<span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> * <span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; 'a <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'a <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">with_connection ?buffer_size ~mode addr f</span> open a connection to
the given address and passes the channels to <span class="code">f</span><br/></p></div><div class="code" id="TYPEserver"><p><span class="keyword">type</span> server</p></div><div class="info"><p>Type of a server<br/></p></div><div class="code" id="VALestablish_server"><p><span class="keyword">val</span> establish_server : <span class="code type"><br/><span class="teletype">   </span>?buffer_size:int -&gt;<br/><span class="teletype">   </span>  ?backlog:int -&gt;<br/><span class="teletype">   </span>  Unix.sockaddr -&gt;<br/><span class="teletype">   </span>  (<span><a href=".././api/Lwt_io#TYPEinput_channel">input_channel</a></span> * <span><a href=".././api/Lwt_io#TYPEoutput_channel">output_channel</a></span> -&gt; unit) -&gt; <span><a href=".././api/Lwt_io#TYPEserver">server</a></span></span></p></div><div class="info"><p><span class="code">establich_server ?buffer_size ?backlog sockaddr f</span> creates a
server which will listen for incomming connections. New
connections are passed to <span class="code">f</span>. Note that <span class="code">f</span> must not raise any
exception.<br/>
</p><p><span class="code">backlog</span> is the argument passed to <span class="code">Lwt_unix.listen</span><br/></p></div><div class="code" id="VALshutdown_server"><p><span class="keyword">val</span> shutdown_server : <span class="code type"><span><a href=".././api/Lwt_io#TYPEserver">server</a></span> -&gt; unit</span></p></div><div class="info"><p>Shutdown the given server<br/></p></div><div class="code" id="VALlines_of_file"><p><span class="keyword">val</span> lines_of_file : <span class="code type"><span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; string <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span></span></p></div><div class="info"><p><span class="code">lines_of_file name</span> returns a stream of all lines of the file
with name <span class="code">name</span>. The file is automatically closed when all
lines have been read.<br/></p></div><div class="code" id="VALlines_to_file"><p><span class="keyword">val</span> lines_to_file : <span class="code type"><span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; string <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">lines_to_file name lines</span> writes all lines of <span class="code">lines</span> to
<span class="code">files</span><br/></p></div><div class="code" id="VALchars_of_file"><p><span class="keyword">val</span> chars_of_file : <span class="code type"><span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; char <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span></span></p></div><div class="info"><p><span class="code">chars_of_file name</span> returns a stream of all characters of the
file with name <span class="code">name</span>. As for <span><a href=".././api/Lwt_io#VALlines_of_file">Lwt_io.lines_of_file</a></span> the file is
closed when all characters have been read.<br/></p></div><div class="code" id="VALchars_to_file"><p><span class="keyword">val</span> chars_to_file : <span class="code type"><span><a href=".././api/Lwt_io#TYPEfile_name">file_name</a></span> -&gt; char <span><a href=".././api/Lwt_stream#TYPEt">Lwt_stream.t</a></span> -&gt; unit <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">chars_to_file name chars</span> writes all characters of <span class="code">chars</span> to
<span class="code">name</span><br/></p></div><p><br/>
</p><h6 id="6_Inputoutputofintegers">Input/output of integers <a class="backref" href="#6_Inputoutputofintegers">&#182;</a></h6><p><br/>
</p><div class="code"><p><span class="keyword">module type</span> <span><a href=".././api/Lwt_io.NumberIO">NumberIO</a></span> = <span class="code">sig</span><span><a href=".././api/Lwt_io.NumberIO">..</a></span><span class="code">end</span></p></div><div class="info"><p>Common interface for reading/writing integers in binary</p></div><div class="code"><p><span class="keyword">module</span> <span><a href=".././api/Lwt_io.LE">LE</a></span>: <span class="code type"><span><a href=".././api/Lwt_io.NumberIO">NumberIO</a></span></span><span class="code type"><span class="teletype">  </span></span></p></div><div class="info"><p>Reading/writing of integers in little-endian</p></div><div class="code"><p><span class="keyword">module</span> <span><a href=".././api/Lwt_io.BE">BE</a></span>: <span class="code type"><span><a href=".././api/Lwt_io.NumberIO">NumberIO</a></span></span><span class="code type"><span class="teletype">  </span></span></p></div><div class="info"><p>Reading/writing of integers in big-endian</p></div><div class="code" id="TYPEbyte_order"><p><span class="keyword">type</span> byte_order = 
</p><table class="typetable"><tr><td class="lefttop"><span class="keyword"><span class="teletype">|</span></span></td><td class="lefttop"><span class="constructor">Little_endian</span></td></tr><tr><td class="lefttop"><span class="keyword"><span class="teletype">|</span></span></td><td class="lefttop"><span class="constructor">Big_endian</span></td></tr></table></div><div class="info"><p>Type of byte order<br/></p></div><div class="code" id="VALsystem_byte_order"><p><span class="keyword">val</span> system_byte_order : <span class="code type"><span><a href=".././api/Lwt_io#TYPEbyte_order">byte_order</a></span></span></p></div><div class="info"><p>The byte order used by the computer running the program<br/></p></div><p><br/>
</p><h6 id="6_Lowlevelaccesstotheinternalbuffer">Low-level access to the internal buffer <a class="backref" href="#6_Lowlevelaccesstotheinternalbuffer">&#182;</a></h6><p><br/>
</p><div class="code" id="VALblock"><p><span class="keyword">val</span> block : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; int -&gt; (<span><a href=".././api/Lwt_bytes#TYPEt">Lwt_bytes.t</a></span> -&gt; int -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">block ch size f</span> pass to <span class="code">f</span> the internal buffer and an
offset. The buffer contains <span class="code">size</span> chars at <span class="code">offset</span>. <span class="code">f</span> may
reads or writes these chars.  <span class="code">size</span> must verify <span class="code">0 &lt;= size &lt;=
16</span><br/></p></div><div class="code" id="TYPEdirect_access"><p><span class="keyword">type</span> direct_access = { 
</p><table class="typetable"><tr><td class="lefttop"><span class="teletype">   </span></td><td class="lefttop">da_buffer : <span class="code type"><span><a href=".././api/Lwt_bytes#TYPEt">Lwt_bytes.t</a></span></span>;</td><td class="typefieldcomment lefttop startcom"><span class="teletype">(*</span></td><td class="typefieldcomment lefttop">The internal buffer</td><td class="typefieldcomment leftbottom endcom"><span class="teletype">*)</span></td></tr><tr><td class="lefttop"><span class="teletype">   </span></td><td class="lefttop"><span class="keyword">mutable </span>da_ptr : <span class="code type">int</span>;</td><td class="typefieldcomment lefttop startcom"><span class="teletype">(*</span></td><td class="typefieldcomment lefttop">The pointer to:* the beginning of free space for output channels
</td></tr></table><ul><li> the beginning of data for input channels
</li></ul><table><tr><td class="typefieldcomment leftbottom endcom"><span class="teletype">*)</span></td></tr><tr><td class="lefttop"><span class="teletype">   </span></td><td class="lefttop"><span class="keyword">mutable </span>da_max : <span class="code type">int</span>;</td><td class="typefieldcomment lefttop startcom"><span class="teletype">(*</span></td><td class="typefieldcomment lefttop">The maximum offset</td><td class="typefieldcomment leftbottom endcom"><span class="teletype">*)</span></td></tr><tr><td class="lefttop"><span class="teletype">   </span></td><td class="lefttop">da_perform : <span class="code type">unit -&gt; int <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span>;</td><td class="typefieldcomment lefttop startcom"><span class="teletype">(*</span></td><td class="typefieldcomment lefttop">- for input channels:
refill the buffer and returns how many bytes have been read* for output channels:
flush partially the buffer and returns how many bytes have been written
</td></tr></table><table><tr><td class="typefieldcomment leftbottom endcom"><span class="teletype">*)</span></td></tr></table><p>}</p></div><div class="info"><p>Informations for accessing directly to the internal buffer of a
channel<br/></p></div><div class="code" id="VALdirect_access"><p><span class="keyword">val</span> direct_access : <span class="code type">'a <span><a href=".././api/Lwt_io#TYPEchannel">channel</a></span> -&gt; (<span><a href=".././api/Lwt_io#TYPEdirect_access">direct_access</a></span> -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span>) -&gt; 'b <span><a href=".././api/Lwt#TYPEt">Lwt.t</a></span></span></p></div><div class="info"><p><span class="code">direct_access ch f</span> pass to <span class="code">f</span> a <span><a href=".././api/Lwt_io#VALdirect_access">Lwt_io.direct_access</a></span>
structure. <span class="code">f</span> must use it and update <span class="code">da_ptr</span> to reflect how
many bytes have been read/written.<br/></p></div><p><br/>
</p><h6 id="6_Misc">Misc <a class="backref" href="#6_Misc">&#182;</a></h6><p><br/>
</p><div class="code" id="VALdefault_buffer_size"><p><span class="keyword">val</span> default_buffer_size : <span class="code type">unit -&gt; int</span></p></div><div class="info"><p>Return the default size for buffers. Channels that are created
without specific size use this one.<br/></p></div><div class="code" id="VALset_default_buffer_size"><p><span class="keyword">val</span> set_default_buffer_size : <span class="code type">int -&gt; unit</span></p></div><div class="info"><p>Change the default buffer size.<br/>
<strong>Raises</strong> <span class="teletype">Invalid_argument</span> if the given size is smaller than <span class="code">16</span>
or greater than <span class="code">Sys.max_string_length</span><br/></p></div></article></div></div></body></html>
